<!DOCTYPE html>
<html> 






<head>
    <link rel="icon" type="image/png" href="https://yt3.googleusercontent.com/Ki7nPuE744r5TVkDdIeBHvMyN5gCnZwpoTnw6LWysB5hIS_nwfPCaVwxjFZglaqFHmwXhep2rw=s160-c-k-c0x00ffffff-no-rj">

    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simbox</title>
    <style>
        canvas {
            border: 1px solid black;
            display: block;
            margin: 0 auto;
        }
        
 
        body {
            text-align: center;
            background-color: rgb(97, 97, 97);
            user-select: none;
            /* Prevent text selection */
        }
 
 
        .material-selector {
            position: fixed;
            top: 50%;
            /* Center vertically */
            left: 0;
            /* Align to the left */
            transform: translateY(-50%);
            background-color: #444;
            padding: 10px;
            border-radius: 0 10px 10px 0;
            color: white;
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            /* Two columns */
            gap: 10px;
            height: 85vh; /* Add this line */
            /* Space between buttons */
            overflow-y: auto;
            /* Allows for scrolling if there are too many items */
        }
 
 
        .material-button {
            margin: 2px;
            padding: 5px;
            cursor: pointer;
            
        }
 
 
        .dropdown {
            margin: 10px;
            padding: 5px;
            background-color: rgba(136, 136, 136, 0.55);
        }
 
 
        .selected {
            border: 2px solid #e9f603;
            /* Optional: highlight border */
            
 
        }
        #pauseButton {
          background-color: rgb(139, 139, 139, 0);
            border: none; /* Remove border */
            color: white; /* Text color */
            font-size: 24px; /* Font size */
            padding: 10px; /* Padding */
            cursor: pointer; /* Cursor style */
            border-radius: 5px; /* Rounded corners */
            position: relative; /* Position for pseudo-elements */
            width: 50px; /* Width of the button */
            height: 50px; /* Height of the button */
        }
 
        #pauseButton::before,
        #pauseButton::after {
            content: ""; /* Required for pseudo-elements */
            position: absolute; /* Positioning */
            width: 10px; /* Width of the bars */
            height: 30px; /* Height of the bars */
            background-color: white; /* Color of the bars */
            top: 10px; /* Position from the top */
        }
 
        #pauseButton::before {
            left: 10px; /* Position for the left bar */
        }
 
        #pauseButton::after {
            right: 10px; /* Position for the right bar */
        }
        #brushSize {
     width: 35px; /* Adjust width as needed */
     font-size: 14px; /* Adjust font size if necessary */
    
   }
        footer {
     position: absolute; /* or 'fixed' */
     bottom: 20px;    /* Adjust positioning */
     right: 20px;   /* based on where you want */
     z-index: 10;  /* Make sure it's above the canvas */
     color:rgb(139, 139, 139);
     padding: 10px;
     width: 190px; /* Set a smaller width */
     font-size: 12px; /* Smaller font size */
     height: 50px; /* Set a smaller height */
   }
  
  
    /* Styles for play button */
    #pauseButton.play::before {
            content: ""; /* Required for pseudo-element */
            position: absolute; /* Positioning */
            width: 0; /* Width of the triangle */
            height: 0; /* Height of the triangle */
            border-left: 20px solid white; /* Left side of the triangle */
            border-top: 15px solid transparent; /* Top side of the triangle */
            border-bottom: 15px solid transparent; /* Bottom side of the triangle */
            left: 10px; /* Position for the triangle */
            top: 10px; /* Position from the top */
        }
        @keyframes glitch {
     0% { text-shadow: 1px 0 red, -1px 0 blue; }
     25% { text-shadow: -1px 0 red, 1px 0 blue; }
     50% { text-shadow: 1px 0 red, -1px 0 blue; }
     75% { text-shadow: -1px 0 red, 1px 0 blue; }
     100% { text-shadow: 1px 0 red, -1px 0 blue; }
 }
 @keyframes uranium {
     0% { text-shadow: 1px 0 green, -1px 0 darkgreen; }
     25% { text-shadow: 1px 0 darkgreen, -1px 0 green; }
     50% { text-shadow: 1px 0 green, -1px 0 rgb(255, 98, 0); }
     75% { text-shadow: 1px 0 orange, -1px 0 red; }
     100% { text-shadow: 1px 0 red, -1px 0 green; }
 }
 
 #glitchButton {
     animation: glitch 1s infinite; /* Add this line */
 }
 #uraniumButton {
 
     animation: uranium 50s; /* Add this line */
 }
 .load-menu {
    position: fixed;
    right: 0;
    top: 50px; /* Adjust as needed */
    width: 250px; /* Width of the menu */
    background-color: #444;
    color: white;
    padding: 10px;
    border-radius: 10px 0 0 10px;
   
    z-index: 1000; /* Ensure it's above other content */
    gap: 10px;
            height: 85vh; /* Add this line */
            /* Space between buttons */
            overflow-y: auto;
}
.savePopUp{
    position:absolute;
    right: 50%;
    top: 25%;
    color: lightgreen;
   
}

    </style>
 </head>
 
 
 <body> 
    
  <canvas id="simulation"></canvas>
    <div class="material-selector">
        <p>Select Material:</p>
        <button style="background-color: rgba(0, 0, 255, 0.544);" class="material-button" onclick="selectedElement = 'water';">Water</button>
        <button style="background-color: #A47449;" class="material-button" onclick="selectedElement = 'wood';">Wood</button>
        <button style="background-color: #ff7700;" class="material-button"  onclick="selectedElement = 'lava';">Lava</button>
        <button style="background-color: yellow;" class="material-button" onclick="selectedElement = 'sand';">Sand</button>
        <button style="background-color: gray;" class="material-button" onclick="selectedElement = 'stone';">Stone</button>
        <button style="background-color: #423223;" class="material-button" onclick="selectedElement = 'mud';">Mud</button>
        <button style="background-color: green;" class="material-button" onclick="selectedElement = 'grass';">Grass</button>
        <button style="background-color: lightblue;" class="material-button" onclick="selectedElement = 'ice';">Ice</button>
        <button style="background-color: #f56a00;" class="material-button" onclick="selectedElement = 'fire';">Fire</button>
        <button style="background-color: white;" class="material-button" onclick="selectedElement = 'snow';">Snow</button>
        <button style="background-color: black; color: white;" class="material-button" onclick="selectedElement = 'oil';">Oil</button>
        <button style="background-color: lightyellow;" class="material-button" onclick="selectedElement = 'sugar';">Sugar</button>
        <button style="background-color: #8B0000;" class="material-button" onclick="selectedElement = 'magma';">Magma</button>
        <button style="background-color: lightgray;" class="material-button" onclick="selectedElement = 'steam';">Steam</button>
        <button style="background-color: #57422E;" class="material-button" onclick="selectedElement = 'dirt';">Dirt</button>
        <button style="background-color: rgba(135, 206, 250, 0.5);" class="material-button" onclick="selectedElement = 'glass';">Glass</button>
        <button style="background-color: #3C2F2F; color: white;" class="material-button" onclick="selectedElement = 'obsidian';">Obsidian</button>
        <button style="background-color: #6b0458;" class="material-button" onclick="selectedElement = 'virus';">Virus</button>
        <button style="background-color: rgba(104, 104, 104, 0.933);" class="material-button" onclick="selectedElement = 'concrete';">Cement</button>
        <button style="background-color: red;" class="material-button" onclick="selectedElement = 'tnt';">Tnt</button>
        <button style="background-color: green;" class="material-button"  id="uraniumButton" onclick="selectedElement = 'uranium';">Uranium</button>
        <button style="background-color: #AC9E91" class="material-button" onclick="selectedElement = 'syrup';">Syrup</button>
        <button style="background-color: #323232" class="material-button" onclick="selectedElement = 'smokeBomb';">Smokebomb</button>
        <button style="background-color: #26C53B" class="material-button" onclick="selectedElement = 'Leaf';">Leaves</button>
        <button style="background-color: #025A01" class="material-button" onclick="selectedElement = 'grenade';">Grenade</button>
        <button style="background-color: pink" class="material-button" onclick="selectedElement = 'crystal';">Crystal</button>
        <button style="background-color: rgb(78, 78, 78); color: white;" class="material-button" onclick="selectedElement = 'basalt';">Basalt</button>
        <button style="background-color: orange" class="material-button" id="glitchButton"  onclick="selectedElement = 'glitch';">Glitch</button>
        <button style="background-color: white"  class="material-button" id="randomButton"  onclick="selectedElement = 'random';">dN0Ram</button>
        <button style="background-color: gray" class="material-button" onclick="selectedElement = 'fly';">Fly</button>
        <button style="background-color: #9E9D90" class="material-button" onclick="selectedElement = 'ash';">Ash</button>
        <button style="background-color: #D5CF8D" class="material-button" onclick="selectedElement = 'human';">Human</button> 
        <button style="background-color: black; color: white;" class="material-button" onclick="selectedElement = 'blackhole';">BlackHole</button>
        <button style="background-color: #8DD5BF" class="material-button" onclick="selectedElement = 'liquidN';">liquidNitrogen</button> 
        <button style="background-color: white" class="material-button" onclick="selectedElement = 'milk';">Milk</button> 
        <button style="background-color: #A4A4A4" class="material-button" onclick="selectedElement = 'steel';">Steel</button>
        <button style="background-color: #D5FB00" class="material-button" onclick="selectedElement = 'sponge';">Sponge</button> 
        <button style="background-color: #C100FF" class="material-button" onclick="selectedElement = 'cloner';">Cloner</button> 
        <button style="background-color: #F7CEFE" class="material-button" onclick="selectedElement = 'salt';">Salt</button> 
        <button style="background-color: #FAB2F5" class="material-button" onclick="selectedElement = 'quartz';">Quartz</button> 
        <button style="background-color: rgba(255, 255, 255, 0.5)" class="material-button" onclick="selectedElement = 'fog';">Fog</button> 
        <button style="background-color: #CDCC9F" class="material-button" onclick="selectedElement = 'bone';">Bone</button>
        <button style="background-color: #7EB534" class="material-button" onclick="selectedElement = 'moss';">Moss</button>
        <button style="background-color: #FF8300" class="material-button" onclick="selectedElement = 'copper';">Copper</button>
        <button style="background-color: #8C8C8C" class="material-button" onclick="selectedElement = 'mercury';">Mercury</button>
        <button style="background-color: green" class="material-button" onclick="selectedElement = 'cactus';">Cactus</button>
        <button style="background-color: #80FF54" class="material-button" onclick="selectedElement = 'acid';">Acid</button>
        <button style="background-color: #474747" class="material-button" onclick="selectedElement = 'gunpowder';">Gunpowder</button>
        <button style="background-color: #FF8700" class="material-button" onclick="selectedElement = 'nitro';">Nitroglycerin</button>
        <button style="background-color: #EAEC42" class="material-button" onclick="selectedElement = 'sawdust';">Sawdust</button>
        <button style="background-color: #97522F" class="material-button" onclick="selectedElement = 'rust';">Rust</button>
        <button style="background-color: #F1EA08" class="material-button" onclick="selectedElement = 'pollen';">Pollen</button>
        <button style="background-color: #C100FF" class="material-button" onclick="selectedElement = 'solidcloner';">Solid Cloner</button> 
        <button style="background-color: #3C3C35; color: white;" class="material-button" onclick="selectedElement = 'coal';">Coal</button>
        <button style="background-color: #ADBFE7" class="material-button" onclick="selectedElement = 'plastic';">Plastic</button> 
        <button style="background-color: #EEE637" class="material-button" onclick="selectedElement = 'lasersource';">laser</button>
        <button style="background-color: #4FC8BE" class="material-button" onclick="selectedElement = 'diamond';">Diamond</button>
        <button style="background-color: white" class="material-button" onclick="selectedElement = 'flashbang';">Flashbang</button>
        <button style="background-color: #595552; color: white;" class="material-button" onclick="selectedElement = 'gallium';">Gallium</button> 
        <button style="background-color: #D12A2A; color: white;" class="material-button" onclick="selectedElement = 'brick';">Brick</button>
        <button class="material-button" onclick="selectedElement = 'empty';">None</button>
        <p>Brush size: <input type="range" id="brushSize"min="1"max="30" value="1"></p>
        <button id="pauseButton"></button> 
       
    </div>
    <button id="saveButton">Save</button>
    <button id="loadButton">Load Game</button>
    
    <div id="hoverInfo" style="position: absolute; bottom: 10px; left: 10px; color: white; font-size: 16px;"></div>
 
    <div id="loadMenu" class="load-menu" style="display: none;">
        <h2>Load Game</h2>
        <div id="saveList"></div>
        <button onclick="closeLoadMenu()">Close</button>
    </div>
 
 <div class="savePopUp" id="savePopUp" style="display: none;">Saving...</div>
   
    <script>
        

        //saving logic
     

        function saveGame() {
    if (isStorageFull()) {
        console.warn("LocalStorage is full. Save aborted to prevent overflow.");
        alert("Unable to save. Memory is full. Please delete old saves.");
        return;
    }

    const gridState = JSON.stringify(grid);
    const saveKey = `gameState_${Date.now()}`;

    // Capture the canvas as an image
    const canvas = document.getElementById('simulation');
    if (!canvas) {
        console.error("Canvas element not found");
        return;
    }
    const imageData = canvas.toDataURL();

    localStorage.setItem(saveKey, gridState);

    // Save metadata
    const saves = JSON.parse(localStorage.getItem('saves')) || [];
    saves.push({ key: saveKey, date: new Date().toLocaleString(), image: imageData });
    localStorage.setItem('saves', JSON.stringify(saves));
    updateLoadMenu();

    console.log("Game saved successfully!");
}

function isStorageFull(limitInBytes = 5 * 1024 * 1024) { // Default limit: 5MB
    let total = 0;
    for (let key in localStorage) {
        if (localStorage.hasOwnProperty(key)) {
            total += key.length + localStorage.getItem(key).length;
        }
    }
    return total >= limitInBytes;
}
function openLoadMenu(){
    document.getElementById('loadMenu').style.display = 'block'; // Show load menu
    return;

}
setInterval(() => {
        document.getElementById('savePopUp').style.display = 'none'; // Show load menu
 }, 1000);
function savepopup(){
    document.getElementById('savePopUp').style.display = 'block'; // Show load menu
  

}
function updateLoadMenu() {
    const saves = JSON.parse(localStorage.getItem('saves')) || [];
    const saveList = document.getElementById('saveList');
    saveList.innerHTML = ''; // Clear previous saves

    saves.forEach((save, index) => {
        const saveItem = document.createElement('div');
        saveItem.style.display = 'flex'; // Use flexbox for layout
        saveItem.style.alignItems = 'center'; // Center items vertically
        saveItem.style.marginBottom = '10px'; // Space between items
        saveItem.innerHTML = `
            <img src="${save.image}" alt="Save Thumbnail" style="width: 50px; height: 50px; margin-right: 10px;" />
            <div style="flex-grow: 1;">
                <p>Date: ${save.date}</p>
            </div>
            <button onclick="loadSpecificGame('${save.key}')">Load</button>
            <button onclick="deleteSave(${index})">Delete</button>
        `;
        saveList.appendChild(saveItem);
    });

    
}
function deleteSave(index) {
    const saves = JSON.parse(localStorage.getItem('saves')) || [];
    
    // Get the save key to delete the associated game state
    const saveToDelete = saves[index]?.key;
    
    if (saveToDelete) {
        localStorage.removeItem(saveToDelete); // Remove the game state from localStorage
    }
    
    // Remove the save metadata at the specified index
    saves.splice(index, 1);
    
    // Update the saves array in localStorage
    localStorage.setItem('saves', JSON.stringify(saves));
    
    // Refresh the load menu to reflect the changes
    updateLoadMenu();
}

function closeLoadMenu() {
    document.getElementById('loadMenu').style.display = 'none'; // Hide load menu
}
function loadSpecificGame(saveKey) {
    const savedState = localStorage.getItem(saveKey);
    if (savedState) {
        const gridState = JSON.parse(savedState);
        
        // Ensure the grid is initialized
        initializeGrid();

        // Restore the grid from the saved state
        for (let row = 0; row < rows; row++) {
            for (let col = 0; col < cols; col++) {
                if (gridState[row] && gridState[row][col]) {
                    grid[row][col] = gridState[row][col];
                }
            }
        }
        drawGrid(); // Redraw the grid to reflect the loaded state
        closeLoadMenu(); // Close the load menu after loading
    } else {
        console.log("No saved game found.");
    }
}
        function loadGame() {
    const savedState = localStorage.getItem('gameState');
    if (savedState) {
        const gridState = JSON.parse(savedState);
        
        // Ensure the grid is initialized
        initializeGrid();

        // Restore the grid from the saved state
        for (let row = 0; row < rows; row++) {
            for (let col = 0; col < cols; col++) {
                if (gridState[row] && gridState[row][col]) {
                    grid[row][col] = gridState[row][col];
                }
            }
        }
        drawGrid(); // Redraw the grid to reflect the loaded state
    } else {
        console.log("No saved game found.");
    }
}
document.getElementById('loadButton').addEventListener('click', updateLoadMenu);
document.getElementById('loadButton').addEventListener('click', openLoadMenu);
        document.getElementById('saveButton').addEventListener('click', saveGame);
        document.getElementById('saveButton').addEventListener('click', savepopup);

 const glitchButton = document.getElementById('glitchButton');
 const originalText = "Glitch"; // Original text
 
 function randomText() {
     const randomChars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789#@!*^%*()&';
     let result = '';
     for (let i = 0; i < originalText.length; i++) {
         result += randomChars.charAt(Math.floor(Math.random() * randomChars.length));
     }
     return result;
 }
 
 function changeTextRandomly() {
     glitchButton.textContent = randomText(); // Change button text to random characters
 
     // Set a random interval for the next text change (between 200ms and 1000ms)
     const randomDelay = Math.floor(Math.random() * (5 - 1 + 1)) + 50; // Random delay between 200ms and 1000ms
     setTimeout(changeTextRandomly, randomDelay);
 }
 
 // Start the first text change
 changeTextRandomly();
 
 // Restore the original text at a fixed interval (optional)
 setInterval(() => {
     glitchButton.textContent = originalText; // Restore original text
 }, 1000); // Restore original text every 5000 milliseconds (5 seconds)
        const canvas = document.getElementById('simulation');
        const ctx = canvas.getContext('2d');
        const width = 800;
        const height = 600;
        const voxelSize = 10; // Default size
 
 
        let showVoxels = false;
        let selectedElement = 'empty';
        let brushSize = 1;
        let isDrawing = false;
        canvas.width = width;
        canvas.height = height;
 
 
        const buttons = document.querySelectorAll('.material-button');
 // Add event listener for the spacebar to pause/unpause
 window.addEventListener('keydown', (e) => {
     if (e.code === 'Space') { // Check if the spacebar is pressed
         e.preventDefault(); // Prevent default spacebar action (scrolling)
         isPaused = !isPaused; // Toggle the paused state
         const button = document.getElementById('pauseButton');
         if (isPaused) {
             button.classList.remove('pause');
             button.classList.add('play');
             
         } else {
             button.classList.remove('play');
             button.classList.add('pause');
           
         }
     }
 });
 
 
 
 
 
 
 
        buttons.forEach(button => {
            button.addEventListener('click', () => {
                // Remove 'selected' class from all buttons
                buttons.forEach(btn => btn.classList.remove('selected'));
                // Add 'selected' class to the clicked button
                button.classList.add('selected');
                // Update the selected element
                selectedElements = button.getAttribute('data-material'); // Update your selectedElement variable
            });
        });
 
 
 
 
 
        function getRandomColorBetween(color1, color2) {
     return Math.random() < 0.5 ? color1 : color2;
 }
 function getRandomColor() {
     const randomColor = Math.floor(Math.random() * 16777215).toString(16);
     return `#${randomColor}`;
 }
 
 function changeGlitchButtonColor() {
     const glitchButton = document.getElementById('glitchButton');
     glitchButton.style.backgroundColor = getRandomColor(); // Set a random color
 }
 
 // Set the interval to change the color every 1000 milliseconds (1 second)
 setInterval(changeGlitchButtonColor, 100);
 
 function changeRandomButtonColor() {
     const randomButton = document.getElementById('randomButton');
     randomButton.style.backgroundColor = getRandomColor(); // Set a random color
 }
 
 // Set the interval to change the color every 1000 milliseconds (1 second)
 setInterval(changeRandomButtonColor, 1000);
 
 
   // Existing brush size input event listener
   document.getElementById('brushSize').addEventListener('input', (e) => {
     brushSize = parseInt(e.target.value, 10);
 });
 
 // New wheel event listener for changing brush size
 canvas.addEventListener('wheel', (e) => {
     e.preventDefault(); // Prevent the default scrolling behavior
     if (e.deltaY < 0) {
         // Scrolling up, increase brush size
         brushSize = Math.min(30, brushSize + 1); // Limit max size to 30
     } else {
         // Scrolling down, decrease brush size
         brushSize = Math.max(1, brushSize - 2); // Limit min size to 1
     }
     document.getElementById('brushSize').value = brushSize; // Update the slider value
 });
        const rows = height / voxelSize;
        const cols = width / voxelSize;
        const grid = [];
 
        const elements = {
            empty: {
                color: '#616171',
                type: 'empty',
                density: 0
               
            },
            water: {
                colors:[ '#1535C6','#100DCE'],
                type: 'liquid',
                density: 1,
                water: true
            },
            lava: {
                colors: ['#Cf1020', '#FF4500', '#FF8C00'],
                type: 'liquid',
                density: 2,
                unsafe: true
            },
            darkLava: {
                color: '#cc5500',
                type: 'liquid',
                density: 2,
                unsafe: true
            },
            magma: {
                colors: ['#8B0000', '#4C1111', '#D53D01'],
                type: 'solid',
                density: 2.5,
                unsafe: true
            },
            basalt: {
             initialColor: '#454545', // Initial color for stone
             color1: '#454545', // Light gray
             color2: '#503534', // Dark gray
                type: 'solid',
                density: 2.8
            },
            obsidian: {
             initialColor: 'rgba(0, 0, 0, 0.5)',
             color1: 'rgba(0, 0, 0, 0.5)',
             color2: '#343434',
                type: 'solid',
                density: 3
            },
            sand: {
                color: '#c2b280', 
                type: 'solid',
                density: 1.5
            },
            stone: {
             initialColor: '#8A8A8A', // Initial color for stone
 
             color1: '#8A8A8A', // Light gray
             color2: '#7E7E7E', // Dark gray
                type: 'solid',
                density: 2.5
            },
            mud: {
                color: '#423223',
                type: 'liquid',
                density: 2
            },
            grass: {
             initialColor: '#0BAD00', // Initial color for stone
             color1: '#0BAD00', // Dark green
             color2: '#10C104', // Light green
                type: 'solid',
                density: 1,
                flammable: true
            },
            ice: {
                color: '#C7FFFD',
                type: 'solid',
                density: 0.8
            },
            oil: {
                color: 'black',
                type: 'liquid',
                density: 0.9,
                flammable: true
            },
            sugar: {
                color: 'lightyellow',
                type: 'solid',
                density: 0.5
            },
            fire: {
                colors: ['#FF4500', '#FF8C00'],
                type: 'gas',
                density: 0,
                unsafe: true
                
            },
            smoke: {
                color: '#738276',
                type: 'gas',
                density: 0.5
            },
            snow: {
                color: 'white',
                type: 'solid',
                density: 0.5
            },
            steam: {
                color: 'lightgray',
                type: 'gas',
                density: 0.1,
                maxAge: 12000
            }, // 120 seconds assuming 60fps
            wood: {
             initialColor: '#AB8564', // Initial color for stone
             color1: '#A28164', // Dark green
             color2: '#AB8564', // Light green
                type: 'solid',
                density: 1.5,
                flammable: true
            },
            dirt: {
                color: '#57422E',
                type: 'solid',
                density: 1.0
            },
            glass: {
                color: 'rgba(135, 206, 250, 0.5)',
                type: 'solid',
                density: 1.9
            }, // Added Glass Element
            moltensand: {
                colors: ['#F36E12', '#DD6513'],
                type: 'liquid',
                density: 2,
                unsafe: true
            },
            lowheatrock:{
             color: '#9A8A7A',
             type: 'solid',
             density: 2,
             unsafe: true
            },
            mediumheatrock:{
             color: '#AA7A6A',
             type: 'solid',
             density: 2,
             unsafe: true
            },
            virus:{
             colors:['#6C04A8', '#7603C1'],
             type: 'solid',
             density: 2,
             flammable: true,
             unsafe: true
            },
            concrete:{
             color:'#7E7E7E',
             type:'liquid',
             density:1.5
            },
            Explosion:{
             color:'#ff4500',
             type: 'gas',
             density: 1,
             unsafe: true
            },
            tnt:{
             color: 'red',
             type:'solid',
             density:1,
             flammable: true,
             unsafe: true
            
            },
            uranium:{
             color:'green',
             type: 'solid',
             density:3,
             unsafe: true
            },
            UExplosion:{
             color:'#ff4500',
             type: 'gas',
             density: 1,
             unsafe: true
            }, 
            syrup:{
             color: '#AC9E91',
             type: 'liquid',
             density: 0.8
            },
            smokeBomb:{
             color:'#323232',
             type: 'solid',
             density: 1,
             unsafe: true
            },
            Leaf:{
             color:'#26C53B',
             type: 'solid',
             density: 0.5,
             flammable: true
            }, 
            grenade: {
             color: '#025A01',
             type: 'solid',
             density: 0.9,
             unsafe: true
            },
            Gexplosion:{
             color: '#025A01',
             type: 'gas',
             density: 1,
             unsafe: true
            },
            crystal: {
             color: 'rgba(232, 132, 232, 0.5)',
             type: 'solid',
             density: 1
            
            },
            glitch: {
     type: 'solid',
     density: 1,
     getColor: function() {
         // Generate a random color in hex format
         const randomColor = Math.floor(Math.random()*16777215).toString(16);
         return `#${randomColor}`;
     },
     unsafe: true
 },
           random:{
             color:'black',
             type: 'solid',
             density: 0
           },
           fly: {
             color:'black',
             type: 'solid',
             density: 0.1
           },
           ash: {
             color: '#9E9D90',
             type: 'solid',
             density: 0.2
           }, 
           human: {
             color: '#D5CF8D',
     type: 'solid',
     density: 1,
     flammable: true
 
    
 },
     blackhole: {
         color:'black',
         type: 'solid',
         density: 1000000000000
 },
     liquidN:{
         color: '#8DD5BF', 
         type: 'liquid',
         density: 1,
         unsafe: true
     },
     milk:{
         color:'white',
         type: 'liquid',
         density: 0.5
     },
     steel:{
         color:'#A4A4A4',
         type: 'solid',
         density: 2
 
     },
     sponge:{
         color:'#D5FB00',
         type: 'solid',
         density: 0.4,
         flammable: true
     },
     wetsponge:{
         color:'#B5D500',
         type: 'solid',
         density: 0.4
     },
     cloner:{
         color:'#C100FF',
         type: 'solid',
         density: 0
     },
     salt:{
         color:'#F7CEFE',
         type: 'solid',
         density: 0.4
     },
     quartz:{
         color:'#FAB2F5',
         type: 'solid',
         density: 1
     }, 
     fog:{
         color: 'lightgray',
         type: 'gas',
         density: 0.1
     },
     bone:{
         color:'#CDCC9F',
         type: 'solid',
         density: 1
     },
     moss:{
        initialColor:'#7EB534',
         color1:'#7EB534',
         color2:'#78AC34',
         type: 'solid',
         density: 0.6,
         flammable: true
     },
     copper:{
         color:'#FF8300',
         type: 'solid',
         density: 1.7
     },
     copper2:{
         color:'#996F33',
         type: 'solid',
         density: 1.7
     },
     copper3:{
         color:'#7B5733',
         type: 'solid',
         density: 1.7
     },
     copper4:{
         color:'#3B7A57',
         type: 'solid',
         density: 1.7
     },
     copper5:{
         color:'#8DBCB9',
         type:'solid',
         density: 1.7
     },
     mercury:{
         color:'#8C8C8C',
         type:'liquid',
         density: 1.5
     },
     cactus:{
         color:'green',
         type: 'solid',
         density: 0.8,
         flammable: true
     },
     acid:{
         color:'#80FF54',
         type: 'liquid', 
         density: 1,
         unsafe: true
     }, 
     gunpowder:{
         color: '#474747',
         type: 'solid',
         density: 0.6,
         unsafe: true,
         flammable: true
     },
     nitro:{
         color: '#FF8700',
         type: 'liquid',
         density: 0.6,
         unsafe: true,
         flammable: true
     },
     nb:{
         color:'red',
         type:'solid',
         density: 2
     },
     sawdust: {
         color: '#EAEC42',
         type: 'solid',
         density: 0.4,
         flammable: true
     },
     saltwater:{
         color:'#8291D6',
         type: 'liquid',
         density: 0.
     },
     wetsand:{
         color:'#A49874',
         type: 'solid',
         density: 1.1
     },
     rust:{
         color:'#A96D6A',
         type: 'solid',
         density: 2
     },
     pollen:{
         color: '#F1EA08',
         type: 'gas',
         density: 0.1,
         flammable: true
     },
     solidcloner:{
         color:'#C100FF',
         type: 'solid',
         density: 0
     },
     coal:{
         color:'#3C3C35',
         type: 'solid',
         density: 1,
         flammable: true
     },
     pwater:{
         color:'#4D6393',
         type: 'liquid',
         density: 1
     },
     plastic:{
         color:'#ADBFE7',
         type: 'solid',
         density: 1
     },
     laser:{
            colors: ['#F2C304', '#EE7F37'],
            type: 'gas',
            density: 100142,
            unsafe: true
        },
        lasersource:{
            colors: ['#F2C304', '#EE7F37'],
            type: 'gas',
            density: 100142,
            unsafe: true
        },
        diamond:{
            initialColor:"#67D3CA",
            color1:"#67D3CA",
            color2:"#4FC8BE",
            type: "solid",
            density: 3
        },
        flashbang:{
            color:'#5F5F5F',
            type: 'solid',
            density: 0.5,
            unsafe: true
        },
        FExplosion:{
            color: 'white',
            type: 'solid',
            density: 0,
            unsafe: true
        },
        flash:{
            color: 'white',
            type: 'gas',
            density: 0,
            unsafe: true
        },
        gallium:{
            color: '#595552',
            type: 'solid',
            density: 0.8,
           
        },
        liquidgallium:{
            color: '#5F5B59',
            type: 'solid',
            density: 0.8
        },
        brick:{
            color: '#D12A2A',
            type: 'solid',
            density: 2
        }
           
        };
        
        const humanMovementDelay = 25; // Delay in frames before human can move again
        function handleHumanMovement(cell, row, col) {
     if (!cell.delay) cell.delay = 0; // Initialize delay counter if not defined
 
     // Check for adjacent lava cells within a 5-cell radius
     const lavaNearby = (r, c) => {
         return grid[r] && grid[r][c] && elements[grid[r][c].element].unsafe;
     };
 
     let hasLavaNearby = false;
     let lavaDirection = null;
 
     // Check a 5-cell radius (11x11 area centered on the human)
     for (let r = -5; r <= 5; r++) {
         for (let c = -5; c <= 5; c++) {
             const newRow = row + r;
             const newCol = col + c;
             if (Math.abs(r) + Math.abs(c) <= 5 && lavaNearby(newRow, newCol)) {
                 hasLavaNearby = true;
                 // Determine the direction of the lava
                 if (r < 0) lavaDirection = 'down'; // Lava is above
                 else if (r > 0) lavaDirection = 'up'; // Lava is below
                 else if (c < 0) lavaDirection = 'right'; // Lava is left
                 else if (c > 0) lavaDirection = 'left'; // Lava is right
                 break;
             }
         }
         if (hasLavaNearby) break; // Exit early if lava is found
     }
 
     // Determine movement delay based on proximity to lava
     const movementDelay = hasLavaNearby ? humanMovementDelay / 10 : humanMovementDelay; // Move faster if near lava
 
     // Increment delay
     cell.delay++;
 
     // Check if the human can fall due to gravity
     if (row < rows - 1 && grid[row + 1][col].element === 'empty') {
         // Move down
         grid[row + 1][col].element = 'human'; // Move the human to the cell below
         cell.element = 'empty'; // Set the old cell to empty
         cell.delay = 0; // Reset delay after moving
         return; // Exit the function after moving down
     }
 
     // If the human cannot fall, check for lateral movement
     if (cell.delay >= movementDelay) { // Check if delay has passed
         const directions = [
             { row: 0, col: -1 }, // Left
             { row: 0, col: 1 },  // Right
         ];
 
         // Determine the opposite direction based on lava direction
         let oppositeDirection = null;
         if (lavaDirection === 'up') oppositeDirection = { row: 1, col: 0 }; // Move down
         else if (lavaDirection === 'down') oppositeDirection = { row: -1, col: 0 }; // Move up
         else if (lavaDirection === 'left') oppositeDirection = { row: 0, col: 1 }; // Move right
         else if (lavaDirection === 'right') oppositeDirection = { row: 0, col: -1 }; // Move left
         
         // If there's a detected lava direction, move in the opposite direction
         if (oppositeDirection) {
             const newRow = row + oppositeDirection.row;
             const newCol = col - oppositeDirection.col;
 
             // Check if the new position is within bounds and empty
             if (newRow >= 0 && newRow < rows && newCol >= 0 && newCol < cols && grid[newRow][newCol].element === 'empty') {
                 grid[newRow][newCol].element = 'human'; // Move the human to the new cell
                 cell.element = 'empty'; // Set the old cell to empty
                 cell.delay = 0; // Reset delay after moving
             } else {
                 // If the cell is not empty, check if there's an empty space above to jump
                 if (row > 0 && newRow < rows && newCol >= 0 && newCol < cols && grid[newRow][newCol].element !== 'empty' && grid[row - 1][newCol].element === 'empty') {
                     grid[row - 1][newCol].element = 'human'; // Move the human to the cell above the obstacle
                     cell.element = 'empty'; // Set the old cell to empty
                     cell.delay = 0; // Reset delay after jumping
                 } else {
                     // If unable to move or jump, reset delay
                     cell.delay = 0; // Reset delay if unable to move
                 }
             }
         } else {
             // If no lava is detected, move randomly
             const randomDirection = directions[Math.floor(Math.random() * directions.length)];
             const newRow = row + randomDirection.row;
             const newCol = col + randomDirection.col;
 
             // Check if the new position is within bounds and empty
             if (newRow >= 0 && newRow < rows && newCol >= 0 && newCol < cols && grid[newRow][newCol].element === 'empty') {
                 grid[newRow][newCol].element = 'human'; // Move the human to the new cell
                 cell.element = 'empty'; // Set the old cell to empty
                 cell.delay = 0; // Reset delay after moving
             } else {
                 // If the cell is not empty, check if there's an empty space above to jump
                 if (row > 0 && newRow < rows && newCol >= 0 && newCol < cols && grid[newRow][newCol].element !== 'empty' && grid[row - 1][newCol].element === 'empty') {
                     grid[row - 1][newCol].element = 'human'; // Move the human to the cell above the obstacle
                     cell.element = 'empty'; // Set the old cell to empty
                     cell.delay = 0; // Reset delay after jumping
                 } else {
                     // If unable to move or jump, reset delay
                     cell.delay = 0; // Reset delay if unable to move
                 }
             }
         }
     }
 }
        function initializeGrid() {
           for (let row = 0; row < rows; row++) {
               grid[row] = [];
               for (let col = 0; col < cols; col++) {
                   grid[row][col] = {
                       element: 'empty',
                       age: 0,
                       uraniumColor: 'green', // Add this line
                       delay: 0,
                       laserdelay: 0
                   };
               }
           }
       }
 
        // Initialize grid with lava properties (if necessary)
        function initializeLavaCell(cell) {
            if (!cell.lastColorChange) {
                cell.lastColorChange = Date.now(); // Set the creation time for the lava cell
                cell.currentColor = elements.lava.colors[Math.floor(Math.random() * elements.lava.colors.length)];
            
            }
        }
        function initializevirusCell(cell) {
            if (!cell.lastColorChange) {
                cell.lastColorChange = Date.now(); // Set the creation time for the lava cell
                cell.currentColor = elements.virus.colors[Math.floor(Math.random() * elements.virus.colors.length)];
            
            }
        }
        function initializesandCell(cell) {
            if (!cell.lastColorChange) {
                cell.lastColorChange = Date.now(); // Set the creation time for the lava cell
                cell.currentColor = elements.sand.colors[Math.floor(Math.random() * elements.sand.colors.length)];
            
            }
        }
        function initializewaterCell(cell) {
            if (!cell.lastColorChange) {
                cell.lastColorChange = Date.now(); // Set the creation time for the lava cell
                cell.currentColor = elements.water.colors[Math.floor(Math.random() * elements.water.colors.length)];
            
            }
        }
      
        
 
 
        // Initialize grid with lava properties (if necessary)
        function initializemagmaCell(cell) {
            if (!cell.lastColorChange) {
                cell.lastColorChange = Date.now(); // Set the creation time for the lava cell
                cell.currentColor = elements.magma.colors[Math.floor(Math.random() * elements.magma.colors.length)];
               
            }
        }
       
        
      // delay in milliseconds for each lava cell
      const magmaColorChangeDelay = 1000; // delay in milliseconds for each lava cell
      const lavaColorChangeDelay = 500; // delay in milliseconds for each lava cell
      const waterColorChangeDelay = 1000; // delay in milliseconds for each lava cell
      const sandColorChangeDelay = 5000; // delay in milliseconds for each lava cell
      const virusColorChangeDelay = 5000; // delay in milliseconds for each lava cell
        function drawGrid() {
         
            ctx.clearRect(0, 0, width, height);
            for (let row = 0; row < rows; row++) {
                for (let col = 0; col < cols; col++) {
                    const cell = grid[row][col];
                    const element = cell.element;
                    ctx.fillRect(col * voxelSize, row * voxelSize, voxelSize, voxelSize);
                    if (element === 'uranium') {
     ctx.fillStyle = cell.uraniumColor;
 } else if (element === 'brick') {
     ctx.fillStyle = cell.brickColor;
 }else    if (element === 'grass') {
    ctx.fillStyle = cell.grassColor || elements.grass.initialColor; // Use the stored stone color or initial color
             } else   if (element === 'diamond') {
     ctx.fillStyle = cell.diamondColor || elements.diamond.initialColor; // Use the stored stone color or initial color
             } else if (element === 'moss') {
     ctx.fillStyle = cell.mossColor || elements.moss.initialColor; // Use the stored stone color or initial color
             } else if (element === 'wood') {
     ctx.fillStyle = cell.woodColor || elements.wood.initialColor; // Use the stored stone color or initial color
             } else if (element === 'stone') {
                 ctx.fillStyle = cell.stoneColor || elements.stone.initialColor; // Use the stored stone color or initial color
             } else if (element === 'basalt') {
                 ctx.fillStyle = cell.basaltColor || elements.basalt.initialColor; // Use the stored stone color or initial color
             } else if (element === 'obsidian') {
                 ctx.fillStyle = cell.obsidianColor || elements.obsidian.initialColor; // Use the stored stone color or initial color
             } else if (element === 'fire') {
                        const fireColors = elements.fire.colors;
                        ctx.fillStyle = fireColors[Math.floor(Math.random() * fireColors.length)];
 
 
                    }  else if (element === 'laser') {
                        const laserColors = elements.laser.colors;
                        ctx.fillStyle = laserColors[Math.floor(Math.random() * laserColors.length)];
 
 
                    } else if (element === 'lasersource') {
                        const lasersourceColors = elements.lasersource.colors;
                        ctx.fillStyle = lasersourceColors[Math.floor(Math.random() * lasersourceColors.length)];
 
 
                    } else if (element === 'glitch') {
         ctx.fillStyle = elements.glitch.getColor(); // Get random color for glitch
     }
  else if (element === 'moltensand') {
                        const sandColors = elements.moltensand.colors;
                        ctx.fillStyle = sandColors[Math.floor(Math.random() * sandColors.length)];
                      
 
                    }else if (element === 'water') {
                        const waterColors = elements.water.colors;
                        ctx.fillStyle = waterColors[Math.floor(Math.random() * waterColors.length)];
                       
 
                    } else if (element === 'lava') {
                        const now = Date.now(); // current time
                        initializeLavaCell(cell); // Initialize if it's a new lava cell
                        
 
                        // Check if the delay has passed for this cell
                        if (now - cell.lastColorChange > lavaColorChangeDelay) {
                            const lavaColors = elements.lava.colors;
                            cell.currentColor = lavaColors[Math.floor(Math.random() * lavaColors.length)];
                            cell.lastColorChange = now; // update the last color change time
                           
                        }
                        ctx.fillStyle = cell.currentColor; // set the current lava color
 
 
                    }else if (element === 'virus') {
                        const now = Date.now(); // current time
                        initializevirusCell(cell); // Initialize if it's a new lava cell
                        
 
                        // Check if the delay has passed for this cell
                        if (now - cell.lastColorChange > virusColorChangeDelay) {
                            const virusColors = elements.virus.colors;
                            cell.currentColor = virusColors[Math.floor(Math.random() * virusColors.length)];
                            cell.lastColorChange = now; // update the last color change time
                           
                        }
                        ctx.fillStyle = cell.currentColor; // set the current lava color
 
 
                    } else if (element === 'magma') {
                        const now = Date.now(); // current time
                        initializemagmaCell(cell); // Initialize if it's a new lava cell
 
 
                        // Check if the delay has passed for this cell
                        if (now - cell.lastColorChange > magmaColorChangeDelay) {
                            const magmaColors = elements.magma.colors;
                            cell.currentColor = magmaColors[Math.floor(Math.random() * magmaColors.length)];
                            cell.lastColorChange = now; // update the last color change time
                           
                        } 
                        ctx.fillStyle = cell.currentColor; // set the current lava color
                    } else {
                        ctx.fillStyle = elements[element].color;
                    }
 
 
                    if (showVoxels) {
                        ctx.strokeStyle = 'black';
                        ctx.strokeRect(col * voxelSize, row * voxelSize, voxelSize, voxelSize);
                    }
                }
            }
             
        }
        const blackHoleRadius = 10; // Define the radius of influence for the black hole
 const pullSpeed = 0.01; // Speed at which elements are pulled towards the black hole
 
        function updateGrid() {
         
            for (let row = rows - 1; row >= 0; row--) {
                for (let col = 0; col < cols; col++) {
                    const cell = grid[row][col];
                    // Ice melting into water
                    if (cell.element === 'ice') {
                        if (Math.random() < 0.005) {
                            grid[row][col].element = 'water';
                        }
                    }
                    if (cell.element === 'syrup') {
     // Check if steam is directly below the water
     if (row < rows - 1 && grid[row + 1][col].element === 'steam') {
         // Swap water with steam
         let steamCell = grid[row + 1][col];
 
         // Swap the elements
         grid[row][col].element = 'steam';
         grid[row + 1][col].element = 'syrup';
 
        
        
 
     }}
     if (cell.element === 'syrup') {
     // Check if steam is directly below the water
     if (row < rows - 1 && grid[row + 1][col].element === 'smoke') {
         // Swap water with steam
         let smokeCell = grid[row + 1][col];
 
         // Swap the elements
         grid[row][col].element = 'smoke';
         grid[row + 1][col].element = 'syrup';
 
        
        
 
     }}
     if (cell.element === 'liquidN') {
     // Check if steam is directly below the water
     if (row < rows - 1 && grid[row + 1][col].element === 'smoke') {
         // Swap water with steam
         let smokeCell = grid[row + 1][col];
 
         // Swap the elements
         grid[row][col].element = 'smoke';
         grid[row + 1][col].element = 'liquidN';
 
        
        
 
     }}
     if (cell.element === 'liquidN') {
     // Check if steam is directly below the water
     if (row < rows - 1 && grid[row + 1][col].element === 'steam') {
         // Swap water with steam
         let steamCell = grid[row + 1][col];
 
         // Swap the elements
         grid[row][col].element = 'steam';
         grid[row + 1][col].element = 'liquidN';
 
        
        
 
     }}
     if (cell.element === 'human') {
     // Check if steam is directly below the water
     if (row < rows - 1 && grid[row + 1][col].element === 'smoke') {
         // Swap water with steam
         let smokeCell = grid[row + 1][col];
 
         // Swap the elements
         grid[row][col].element = 'smoke';
         grid[row + 1][col].element = 'human';
 
         
        
 
     }}
     if (cell.element === 'water') {
     // Check if steam is directly below the water
     if (row < rows - 1 && grid[row + 1][col].element === 'steam') {
         // Swap water with steam
         let steamCell = grid[row + 1][col];
 
         // Swap the elements
         grid[row][col].element = 'steam';
         grid[row + 1][col].element = 'water';
 
         // Swap the ages
        
 
     }}
     if (cell.element === 'sugar') {
     // Check if steam is directly below the water
     if (row < rows - 1 && grid[row + 1][col].element === 'steam') {
         // Swap water with steam
         let steamCell = grid[row + 1][col];
 
         // Swap the elements
         grid[row][col].element = 'steam';
         grid[row + 1][col].element = 'sugar';
 
        
 
      
     }}
     if (cell.element === 'lava') {
     // Check if steam is directly below the water
     if (row < rows - 1 && grid[row + 1][col].element === 'steam') {
         // Swap water with steam
         let steamCell = grid[row + 1][col];
 
         // Swap the elements
         grid[row][col].element = 'steam';
         grid[row + 1][col].element = 'lava';
 
         
        
 
     }}
     if (cell.element === 'mercury') {
     // Check if steam is directly below the water
     if (row < rows - 1 && grid[row + 1][col].element === 'steam') {
         // Swap water with steam
         let steamCell = grid[row + 1][col];
 
         // Swap the elements
         grid[row][col].element = 'steam';
         grid[row + 1][col].element = 'mercury';
 
         
        
 
     }}
     if (cell.element === 'mercury') {
     // Check if steam is directly below the water
     if (row < rows - 1 && grid[row + 1][col].element === 'smoke') {
         // Swap water with steam
         let smokeCell = grid[row + 1][col];
 
         // Swap the elements
         grid[row][col].element = 'smoke';
         grid[row + 1][col].element = 'mercury';
 
         
        
 
     }}
     if (cell.element === 'human') {
     // Check if steam is directly below the water
     if (row < rows - 1 && grid[row + 1][col].element === 'steam') {
         // Swap water with steam
         let steamCell = grid[row + 1][col];
 
         // Swap the elements
         grid[row][col].element = 'steam';
         grid[row + 1][col].element = 'human';
 
         
        
 
     }}
     if (cell.element === 'gunpowder') {
     // Check if steam is directly below the water
     if (row < rows - 1 && grid[row + 1][col].element === 'steam') {
         // Swap water with steam
         let steamCell = grid[row + 1][col];
 
         // Swap the elements
         grid[row][col].element = 'steam';
         grid[row + 1][col].element = 'gunpowder';
 
         
        
 
     }}
     if (cell.element === 'nitro') {
     // Check if steam is directly below the water
     if (row < rows - 1 && grid[row + 1][col].element === 'steam') {
         // Swap water with steam
         let steamCell = grid[row + 1][col];
 
         // Swap the elements
         grid[row][col].element = 'steam';
         grid[row + 1][col].element = 'nitro';
 
         
        
 
     }}
     if (cell.element === 'nitro') {
     // Check if steam is directly below the water
     if (row < rows - 1 && grid[row + 1][col].element === 'smoke') {
         // Swap water with steam
         let smokeCell = grid[row + 1][col];
 
         // Swap the elements
         grid[row][col].element = 'smoke';
         grid[row + 1][col].element = 'nitro';
 
         
        
 
     }}
     if (cell.element === 'gunpowder') {
     // Check if steam is directly below the water
     if (row < rows - 1 && grid[row + 1][col].element === 'smoke') {
         // Swap water with steam
         let smokeCell = grid[row + 1][col];
 
         // Swap the elements
         grid[row][col].element = 'smoke';
         grid[row + 1][col].element = 'gunpowder';
 
         
        
 
     }}
     if (cell.element === 'moltensand') {
     // Check if steam is directly below the water
     if (row < rows - 1 && grid[row + 1][col].element === 'steam') {
         // Swap water with steam
         let steamCell = grid[row + 1][col];
 
         // Swap the elements
         grid[row][col].element = 'steam';
         grid[row + 1][col].element = 'moltensand';
 
      
        
 
     }}
     if (cell.element === 'magma') {
     // Check if steam is directly below the water
     if (row < rows - 1 && grid[row + 1][col].element === 'steam') {
         // Swap water with steam
         let steamCell = grid[row + 1][col];
         
         // Swap the elements
         grid[row][col].element = 'steam';
         grid[row + 1][col].element = 'magma';
 
        
 
     }}
     if (cell.element === 'sand') {
     // Check if steam is directly below the water
     if (row < rows - 1 && grid[row + 1][col].element === 'steam') {
         // Swap water with steam
         let steamCell = grid[row + 1][col];
 
         // Swap the elements
         grid[row][col].element = 'steam';
         grid[row + 1][col].element = 'sand';
 
       
     
 
     }}
     if (cell.element === 'oil') {
     // Check if steam is directly below the water
     if (row < rows - 1 && grid[row + 1][col].element === 'water') {
         // Swap water with steam
         let oilCell = grid[row + 1][col];
 
         // Swap the elements
         grid[row][col].element = 'water';
         grid[row + 1][col].element = 'oil';
 
       
     
 
     }}
     if (cell.element === 'dirt') {
     // Check if steam is directly below the water
     if (row < rows - 1 && grid[row + 1][col].element === 'steam') {
         // Swap water with steam
         let steamCell = grid[row + 1][col];
 
         // Swap the elements
         grid[row][col].element = 'steam';
         grid[row + 1][col].element = 'dirt';
 
     
       
 
     }}
     if (cell.element === 'oil') {
     // Check if steam is directly below the water
     if (row < rows - 1 && grid[row + 1][col].element === 'steam') {
         // Swap water with steam
         let steamCell = grid[row + 1][col];
 
         // Swap the elements
         grid[row][col].element = 'steam';
         grid[row + 1][col].element = 'oil';
 
      
        
 
     }}
     if (cell.element === 'oil') {
     // Check if steam is directly below the water
     if (row < rows - 1 && grid[row + 1][col].element === 'smoke') {
         // Swap water with steam
         let smokeCell = grid[row + 1][col];
 
         // Swap the elements
         grid[row][col].element = 'smoke';
         grid[row + 1][col].element = 'oil';
 
        
        
 
     }}
 
     if (cell.element === 'water') {
     // Check if steam is directly below the water
     if (row < rows - 1 && grid[row + 1][col].element === 'smoke') {
         // Swap water with steam
         let smokeCell = grid[row + 1][col];
 
         // Swap the elements
         grid[row][col].element = 'smoke';
         grid[row + 1][col].element = 'water';
 
        
        
 
     }}
 
     if (cell.element === 'concrete') {
     // Check if steam is directly below the water
     if (row < rows - 1 && grid[row + 1][col].element === 'smoke') {
         // Swap water with steam
         let smokeCell = grid[row + 1][col];
 
         // Swap the elements
         grid[row][col].element = 'smoke';
         grid[row + 1][col].element = 'concrete';
 
        
        
 
     }}
     if (cell.element === 'concrete') {
     // Check if steam is directly below the water
     if (row < rows - 1 && grid[row + 1][col].element === 'steam') {
         // Swap water with steam
         let steamCell = grid[row + 1][col];
 
         // Swap the elements
         grid[row][col].element = 'steam';
         grid[row + 1][col].element = 'concrete';
 
        
        
 
     }}
     if (cell.element === 'sugar') {
     // Check if steam is directly below the water
     if (row < rows - 1 && grid[row + 1][col].element === 'smoke') {
         // Swap water with steam
         let smokeCell = grid[row + 1][col];
 
         // Swap the elements
         grid[row][col].element = 'smoke';
         grid[row + 1][col].element = 'sugar';
 
        
 
     }}
     if (cell.element === 'lava') {
     // Check if steam is directly below the water
     if (row < rows - 1 && grid[row + 1][col].element === 'smoke') {
         // Swap water with steam
         let smokeCell = grid[row + 1][col];
 
         // Swap the elements
         grid[row][col].element = 'smoke';
         grid[row + 1][col].element = 'lava';
 
        
 
     }}
     if (cell.element === 'milk') {
     // Check if steam is directly below the water
     if (row < rows - 1 && grid[row + 1][col].element === 'smoke') {
         // Swap water with steam
         let smokeCell = grid[row + 1][col];
 
         // Swap the elements
         grid[row][col].element = 'smoke';
         grid[row + 1][col].element = 'milk';
 
        
 
     }}
     if (cell.element === 'milk') {
     // Check if steam is directly below the water
     if (row < rows - 1 && grid[row + 1][col].element === 'steam') {
         // Swap water with steam
         let steamCell = grid[row + 1][col];
 
         // Swap the elements
         grid[row][col].element = 'steam';
         grid[row + 1][col].element = 'milk';
 
        
 
     }}
     if (cell.element === 'sawdust') {
     // Check if steam is directly below the water
     if (row < rows - 1 && grid[row + 1][col].element === 'steam') {
         // Swap water with steam
         let steamCell = grid[row + 1][col];
 
         // Swap the elements
         grid[row][col].element = 'steam';
         grid[row + 1][col].element = 'sawdust';
 
        
 
     }}
     if (cell.element === 'sawdust') {
     // Check if steam is directly below the water
     if (row < rows - 1 && grid[row + 1][col].element === 'smoke') {
         // Swap water with steam
         let smokeCell = grid[row + 1][col];
 
         // Swap the elements
         grid[row][col].element = 'smoke';
         grid[row + 1][col].element = 'sawdust';
 
        
 
     }}
     if (cell.element === 'moltensand') {
     // Check if steam is directly below the water
     if (row < rows - 1 && grid[row + 1][col].element === 'smoke') {
         // Swap water with steam
         let smokeCell = grid[row + 1][col];
 
         // Swap the elements
         grid[row][col].element = 'smoke';
         grid[row + 1][col].element = 'moltensand';
 
         
        
 
     }}
     if (cell.element === 'saltwater') {
     // Check if steam is directly below the water
     if (row < rows - 1 && grid[row + 1][col].element === 'smoke') {
         // Swap water with steam
         let smokeCell = grid[row + 1][col];
 
         // Swap the elements
         grid[row][col].element = 'smoke';
         grid[row + 1][col].element = 'saltwater';
 
         
        
 
     }}
     if (cell.element === 'saltwater') {
     // Check if steam is directly below the water
     if (row < rows - 1 && grid[row + 1][col].element === 'steam') {
         // Swap water with steam
         let steamCell = grid[row + 1][col];
 
         // Swap the elements
         grid[row][col].element = 'steam';
         grid[row + 1][col].element = 'saltwater';
 
         
        
 
     }}
     if (cell.element === 'pwater') {
     // Check if steam is directly below the water
     if (row < rows - 1 && grid[row + 1][col].element === 'steam') {
         // Swap water with steam
         let steamCell = grid[row + 1][col];
 
         // Swap the elements
         grid[row][col].element = 'steam';
         grid[row + 1][col].element = 'pwater';
 
         
        
 
     }}
     if (cell.element === 'pwater') {
     // Check if steam is directly below the water
     if (row < rows - 1 && grid[row + 1][col].element === 'smoke') {
         // Swap water with steam
         let smokeCell = grid[row + 1][col];
 
         // Swap the elements
         grid[row][col].element = 'smoke';
         grid[row + 1][col].element = 'pwater';
 
         
        
 
     }}
     if (cell.element === 'salt') {
     // Check if steam is directly below the water
     if (row < rows - 1 && grid[row + 1][col].element === 'smoke') {
         // Swap water with steam
         let smokeCell = grid[row + 1][col];
 
         // Swap the elements
         grid[row][col].element = 'smoke';
         grid[row + 1][col].element = 'salt';
 
         
        
 
     }}
     if (cell.element === 'salt') {
     // Check if steam is directly below the water
     if (row < rows - 1 && grid[row + 1][col].element === 'steam') {
         // Swap water with steam
         let steamCell = grid[row + 1][col];
 
         // Swap the elements
         grid[row][col].element = 'steam';
         grid[row + 1][col].element = 'salt';
 
         
        
 
     }}
     if (cell.element === 'magma') {
     // Check if steam is directly below the water
     if (row < rows - 1 && grid[row + 1][col].element === 'smoke') {
         // Swap water with steam
         let smokeCell = grid[row + 1][col];
 
         // Swap the elements
         grid[row][col].element = 'smoke';
         grid[row + 1][col].element = 'magma';
 
        
 
     }}
     if (cell.element === 'sand') {
     // Check if steam is directly below the water
     if (row < rows - 1 && grid[row + 1][col].element === 'smoke') {
         // Swap water with steam
         let smokeCell = grid[row + 1][col];
 
         // Swap the elements
         grid[row][col].element = 'smoke';
         grid[row + 1][col].element = 'sand';
 
       
 
     }}
     if (cell.element === 'dirt') {
     // Check if steam is directly below the water
     if (row < rows - 1 && grid[row + 1][col].element === 'smoke') {
         // Swap water with steam
         let smokeCell = grid[row + 1][col];
 
         // Swap the elements
         grid[row][col].element = 'smoke';
         grid[row + 1][col].element = 'dirt';
 
         
       
 
     }}
     if (cell.element === 'concrete') {
     // Check if steam is directly below the water
     if (row < rows - 1 && grid[row + 1][col].element === 'water') {
         // Swap water with steam
         let waterCell = grid[row - 1][col];
 
         // Swap the elements
         grid[row][col].element = 'water';
         grid[row + 1][col].element = 'concrete';
 
       
 
     }}
     if (cell.element === 'human') {
     // Check if steam is directly below the water
     if (row < rows - 1 && grid[row + 1][col].element === 'water') {
         // Swap water with steam
         let waterCell = grid[row - 1][col];
 
         // Swap the elements
         grid[row][col].element = 'water';
         grid[row + 1][col].element = 'human';
 
       
 
     }}
     if (cell.element === 'snow') {
     // Check if steam is directly below the water
     if (row < rows - 1 && grid[row + 1][col].element === 'water') {
         // Swap water with steam
         let waterCell = grid[row - 1][col];
 
         // Swap the elements
         grid[row][col].element = 'water';
         grid[row + 1][col].element = 'snow';
 
       
 
     }}
     if (cell.element === 'grenade') {
     // Check if steam is directly below the water
     if (row < rows - 1 && grid[row + 1][col].element === 'water') {
         // Swap water with steam
         let waterCell = grid[row - 1][col];
 
         // Swap the elements
         grid[row][col].element = 'water';
         grid[row + 1][col].element = 'grenade';
 
       
 
     }}
     if (cell.element === 'mercury') {
     // Check if steam is directly below the water
     if (row < rows - 1 && grid[row + 1][col].element === 'water') {
         // Swap water with steam
         let waterCell = grid[row - 1][col];
 
         // Swap the elements
         grid[row][col].element = 'water';
         grid[row + 1][col].element = 'mercury';
 
       
 
     }}
     if (cell.element === 'cactus') {
     // Check if steam is directly below the water
     if (row < rows - 1 && grid[row + 1][col].element === 'water') {
         // Swap water with steam
         let waterCell = grid[row - 1][col];
 
         // Swap the elements
         grid[row][col].element = 'water';
         grid[row + 1][col].element = 'cactus';
 
       
 
     }}
     if (cell.element === 'gunpowder') {
     // Check if steam is directly below the water
     if (row < rows - 1 && grid[row + 1][col].element === 'water') {
         // Swap water with steam
         let waterCell = grid[row - 1][col];
 
         // Swap the elements
         grid[row][col].element = 'water';
         grid[row + 1][col].element = 'gunpowder';
 
       
 
     }}
     if (cell.element === 'gunpowder') {
     // Check if steam is directly below the water
     if (row < rows - 1 && grid[row + 1][col].element === 'pwater') {
         // Swap water with steam
         let pwaterCell = grid[row - 1][col];
 
         // Swap the elements
         grid[row][col].element = 'pwater';
         grid[row + 1][col].element = 'gunpowder';
 
       
 
     }}
     if (cell.element === 'dirt') {
     // Check if steam is directly below the water
     if (row < rows - 1 && grid[row + 1][col].element === 'pwater') {
         // Swap water with steam
         let pwaterCell = grid[row - 1][col];
 
         // Swap the elements
         grid[row][col].element = 'pwater';
         grid[row + 1][col].element = 'dirt';
 
       
 
     }}
     if (cell.element === 'concrete') {
     // Check if steam is directly below the water
     if (row < rows - 1 && grid[row + 1][col].element === 'pwater') {
         // Swap water with steam
         let pwaterCell = grid[row - 1][col];
 
         // Swap the elements
         grid[row][col].element = 'pwater';
         grid[row + 1][col].element = 'concrete';
 
       
 
     }}
     if (cell.element === 'gunpowder') {
     // Check if steam is directly below the water
     if (row < rows - 1 && grid[row + 1][col].element === 'nitro') {
         // Swap water with steam
         let nitroCell = grid[row - 1][col];
 
         // Swap the elements
         grid[row][col].element = 'nitro';
         grid[row + 1][col].element = 'gunpowder';
 
       
 
     }}
     if (cell.element === 'dirt') {
     // Check if steam is directly below the water
     if (row < rows - 1 && grid[row + 1][col].element === 'nitro') {
         // Swap water with steam
         let nitroCell = grid[row - 1][col];
 
         // Swap the elements
         grid[row][col].element = 'nitro';
         grid[row + 1][col].element = 'dirt';
 
       
 
     }}
     if (cell.element === 'sand') {
     // Check if steam is directly below the water
     if (row < rows - 1 && grid[row + 1][col].element === 'nitro') {
         // Swap water with steam
         let nitroCell = grid[row - 1][col];
 
         // Swap the elements
         grid[row][col].element = 'nitro';
         grid[row + 1][col].element = 'sand';
 
       
 
     }}
     if (cell.element === 'cactus') {
     // Check if steam is directly below the water
     if (row < rows - 1 && grid[row + 1][col].element === 'nitro') {
         // Swap water with steam
         let nitroCell = grid[row - 1][col];
 
         // Swap the elements
         grid[row][col].element = 'nitro';
         grid[row + 1][col].element = 'cactus';
 
       
 
     }}
     if (cell.element === 'mercury') {
     // Check if steam is directly below the water
     if (row < rows - 1 && grid[row + 1][col].element === 'nitro') {
         // Swap water with steam
         let nitroCell = grid[row - 1][col];
 
         // Swap the elements
         grid[row][col].element = 'nitro';
         grid[row + 1][col].element = 'mercury';
 
       
     }}
     if (cell.element === 'salt') {
     // Check if steam is directly below the water
     if (row < rows - 1 && grid[row + 1][col].element === 'nitro') {
         // Swap water with steam
         let nitroCell = grid[row - 1][col];
 
         // Swap the elements
         grid[row][col].element = 'nitro';
         grid[row + 1][col].element = 'salt';
 
       
     }}
     if (cell.element === 'snow') {
     // Check if steam is directly below the water
     if (row < rows - 1 && grid[row + 1][col].element === 'nitro') {
         // Swap water with steam
         let nitroCell = grid[row - 1][col];
 
         // Swap the elements
         grid[row][col].element = 'nitro';
         grid[row + 1][col].element = 'snow';
 
       
     }}
     if (cell.element === 'milk') {
     // Check if steam is directly below the water
     if (row < rows - 1 && grid[row + 1][col].element === 'nitro') {
         // Swap water with steam
         let nitroCell = grid[row - 1][col];
 
         // Swap the elements
         grid[row][col].element = 'nitro';
         grid[row + 1][col].element = 'milk';
 
       
     }}
     if (cell.element === 'human') {
     // Check if steam is directly below the water
     if (row < rows - 1 && grid[row + 1][col].element === 'nitro') {
         // Swap water with steam
         let nitroCell = grid[row - 1][col];
 
         // Swap the elements
         grid[row][col].element = 'nitro';
         grid[row + 1][col].element = 'human';
 
       
     }}
     if (cell.element === 'sugar') {
     // Check if steam is directly below the water
     if (row < rows - 1 && grid[row + 1][col].element === 'nitro') {
         // Swap water with steam
         let nitroCell = grid[row - 1][col];
 
         // Swap the elements
         grid[row][col].element = 'nitro';
         grid[row + 1][col].element = 'sugar';
 
       
     }}
     if (cell.element === 'concrete') {
     // Check if steam is directly below the water
     if (row < rows - 1 && grid[row + 1][col].element === 'nitro') {
         // Swap water with steam
         let nitroCell = grid[row - 1][col];
 
         // Swap the elements
         grid[row][col].element = 'nitro';
         grid[row + 1][col].element = 'concrete';
 
       
     }}
     if(cell.element==='virus'){
         cell.age++;
         if(cell.age >=39){
             if (Math.random() < 0.6) {
             cell.element='empty'
             cell.age=0;}
         }
     }
     
     if (cell.element === 'empty'){
         const adjacentCells = [{
                                row: row - 1,
                                col: col
                            }, // Up
                            {
                                row: row + 1,
                                col: col
                            }, // Down
                            {
                                row: row,
                                col: col - 1
                            }, // Left
                            {
                                row: row,
                                col: col + 1
                            } // Right
                        ];
 
                        // Check for adjacent grass cells
                        let emptyAdjacent = adjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'virus'
                        );
 
 
 
 
 
 
 
 
                        // If water is adjacent to grass, start or increment the delay
                        if (emptyAdjacent) {
                            cell.delay++;
 
 
 
 
 
 
 
 
                            // Replace water with grass after delay of 30 frames
                            if (cell.delay === 41) {
                                cell.element = 'virus';
                               
                            }
                        } else {
                            // Reset delay if not adjacent to grass
                            cell.delay = 0;
                        }
 
     }
     if (cell.element === 'random') {
                 // List of possible elements to replace the virus
                 const possibleElements = Object.keys(elements).filter(el => el !== 'random' && el !== 'empty');
                 const randomElement = possibleElements[Math.floor(Math.random() * possibleElements.length)];
 
                 // Replace virus with a random element
                 cell.element = randomElement;
                 cell.age = 0; // Reset age when replaced
             }
     if (cell.element === 'grass'){
         const adjacentCells = [{
                                row: row - 1,
                                col: col
                            }, // Up
                            {
                                row: row + 1,
                                col: col
                            }, // Down
                            {
                                row: row,
                                col: col - 1
                            }, // Left
                            {
                                row: row,
                                col: col + 1
                            } // Right
                        ];
 
                        // Check for adjacent grass cells
                        let  vAdjacent = adjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'virus'
                        );
 
 
 
 
 
 
 
 
                        // If water is adjacent to grass, start or increment the delay
                        if (vAdjacent) {
                            cell.delay++;
 
 
 
 
 
 
 
 
                            // Replace water with grass after delay of 30 frames
                            if (cell.delay >= 27) {
                             if (Math.random() < 0.8) {
                                cell.element = 'virus';
                             } 
                            }
                        } else {
                            // Reset delay if not adjacent to grass
                            cell.delay = 0;
                        }
 
     }
   
     if (cell.element === 'Leaf'){
         const adjacentCells = [{
                                row: row - 1,
                                col: col
                            }, // Up
                            {
                                row: row + 1,
                                col: col
                            }, // Down
                            {
                                row: row,
                                col: col - 1
                            }, // Left
                            {
                                row: row,
                                col: col + 1
                            } // Right
                        ];
 
                        // Check for adjacent grass cells
                        let  lAdjacent = adjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'virus'
                        );
 
 
 
 
 
 
 
 
                        // If water is adjacent to grass, start or increment the delay
                        if (lAdjacent) {
                            cell.delay++;
 
 
 
 
 
 
 
 
                            // Replace water with grass after delay of 30 frames
                            if (cell.delay >= 27) {
                             if (Math.random() < 0.8) {
                                cell.element = 'virus';
                             }
                            }
                        } else {
                            // Reset delay if not adjacent to grass
                            cell.delay = 0;
                        }
 
     }
     if (cell.element === 'steel'){
         const adjacentCells = [{
                                row: row - 1,
                                col: col
                            }, // Up
                            {
                                row: row + 1,
                                col: col
                            }, // Down
                            {
                                row: row,
                                col: col - 1
                            }, // Left
                            {
                                row: row,
                                col: col + 1
                            } // Right
                        ];
 
                        // Check for adjacent grass cells
                        let  stAdjacent = adjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'water'
                        );
 
 
 
 
 
 
 
 
                        // If water is adjacent to grass, start or increment the delay
                        if (stAdjacent) {
                            cell.delay++;
 
 
 
 
 
 
 
 
                            // Replace water with grass after delay of 30 frames
                            if (cell.delay >= 300) {
                             if (Math.random() < 0.8) {
                                cell.element = 'rust';
                             }
                            }
                        } 
 
     }
     if(cell.element==='copper'){
         cell.age++;
         if(cell.age>500){
            
             cell.element='copper2';
             cell.age=0;
             
         }
     }
     if(cell.element==='copper2'){
         cell.age++;
         if(cell.age>500){
            
             cell.element='copper3';
             cell.age=0;
             
         }
     }
     if(cell.element==='copper3'){
         cell.age++;
         if(cell.age>500){
            
             cell.element='copper4';
             cell.age=0;
             
         }
     }
     if(cell.element==='copper4'){
         cell.age++;
         if(cell.age>500){
            
             cell.element='copper5';
             cell.age=0;
             
         }
     }
     if (cell.element === 'tnt'){
         const adjacentCells = [{
                                row: row - 1,
                                col: col
                            }, // Up
                            {
                                row: row + 1,
                                col: col
                            }, // Down
                            {
                                row: row,
                                col: col - 1
                            }, // Left
                            {
                                row: row,
                                col: col + 1
                            } // Right
                        ];
 
                        // Check for adjacent grass cells
                        let tntAdjacent = adjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'fire'
                        );
 
 
 
 
 
 
 
 
                        // If water is adjacent to grass, start or increment the delay
                        if (tntAdjacent) {
                            cell.delay++;
 
 
 
 
 
 
 
 
                            // Replace water with grass after delay of 30 frames
                            if (cell.delay >= 10) {
                                cell.element = 'Explosion';
                               
                            }
                        } else {
                            // Reset delay if not adjacent to grass
                            cell.delay = 0;
                        }
 
     }
     if (cell.element === 'nitro'){
         const adjacentCells = [{
                                row: row - 1,
                                col: col
                            }, // Up
                            {
                                row: row + 1,
                                col: col
                            }, // Down
                            {
                                row: row,
                                col: col - 1
                            }, // Left
                            {
                                row: row,
                                col: col + 1
                            } // Right
                        ];
 
                        // Check for adjacent grass cells
                        let nAdjacent = adjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'fire'
                        );
 
 
 
 
 
 
 
 
                        // If water is adjacent to grass, start or increment the delay
                        if (nAdjacent) {
                            cell.delay++;
 
 
 
 
 
 
 
 
                            // Replace water with grass after delay of 30 frames
                            if (cell.delay >= 10) {
                                cell.element = 'nb';
                               
                            }
                        } else {
                            // Reset delay if not adjacent to grass
                            cell.delay = 0;
                        }
 
     }
     if (cell.element === 'gunpowder'){
         const adjacentCells = [{
                                row: row - 1,
                                col: col
                            }, // Up
                            {
                                row: row + 1,
                                col: col
                            }, // Down
                            {
                                row: row,
                                col: col - 1
                            }, // Left
                            {
                                row: row,
                                col: col + 1
                            } // Right
                        ];
 
                        // Check for adjacent grass cells
                        let gunpAdjacent = adjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'fire'
                        );
 
 
 
 
 
 
 
 
                        // If water is adjacent to grass, start or increment the delay
                        if (gunpAdjacent) {
                            cell.delay++;
 
 
 
 
 
 
 
 
                            // Replace water with grass after delay of 30 frames
                            if (cell.delay >= 10) {
                                cell.element = 'Explosion';
                               
                            }
                        } else {
                            // Reset delay if not adjacent to grass
                            cell.delay = 0;
                        }
 
     }
     if (cell.element === 'ice'){
         const adjacentCells = [{
                                row: row - 1,
                                col: col
                            }, // Up
                            {
                                row: row + 1,
                                col: col
                            }, // Down
                            {
                                row: row,
                                col: col - 1
                            }, // Left
                            {
                                row: row,
                                col: col + 1
                            } // Right
                        ];
 
                        // Check for adjacent grass cells
                        let wAdjacent = adjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'Lava'  
                        );
                   
 
 
 
 
 
 
 
                        // If water is adjacent to grass, start or increment the delay
                        if (wAdjacent) {
                            cell.delay++;
 
 
 
 
 
 
 
 
                            // Replace water with grass after delay of 30 frames
                            if (cell.delay >= 5) {
                                cell.element = 'water';
                               
                            }
                        } else {
                            // Reset delay if not adjacent to grass
                            cell.delay = 0;
                        }
 
     }
     if (cell.element === 'water'){
         const adjacentCells = [{
                                row: row - 1,
                                col: col
                            }, // Up
                            {
                                row: row + 1,
                                col: col
                            }, // Down
                            {
                                row: row,
                                col: col - 1
                            }, // Left
                            {
                                row: row,
                                col: col + 1
                            } // Right
                        ];
 
                        // Check for adjacent grass cells
                        let NAdjacent = adjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'liquidN'  
                        );
                      
 
 
 
 
 
 
 
                        // If water is adjacent to grass, start or increment the delay
                        if (NAdjacent) {
                            cell.delay++;
 
 
 
 
 
 
 
 
                            // Replace water with grass after delay of 30 frames
                          
                                cell.element = 'ice';
                             
                            cell.age=-50;
                        } 
 
     }
   
     if(cell.element==='laser'){
              cell.age++;
                   if(cell.age >= 0){
                        cell.element='empty';
                   }
                } 
                if(cell.element==='lasersource'){
              cell.age++;
                   if(cell.age >= 2){
                        cell.element='empty';
                   }
                } 
             
             
             if (cell.element === 'lasersource') {
                // Change the entire column below to laser
                for (let r = row + 1; r < rows; r++) {
                    if (grid[r][col].element === 'empty' || grid[r][col].element === 'laser') {
                        grid[r][col].element = 'laser'; // Change to laser
                        grid[r][col].age = 0;
                    } else {
                        break; // Stop if we hit a non-empty cell
                    }
                }
            }
            if(cell.element==='stone'){
                const laseradjacentCells = [{
                                row: row - 1,
                                col: col
                            }, // Up
                            {
                                row: row + 1,
                                col: col
                            }, // Down
                            {
                                row: row,
                                col: col - 1
                            }, // Left
                            {
                                row: row,
                                col: col + 1
                            } // Right
                        ];
                        const laserAdjacent = laseradjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'laser'
                        );
 
 
 
 
 
 
 
 
                        // If water is adjacent to grass, start or increment the delay
                        if (laserAdjacent) {
                            cell.laserdelay++;
 
 
 
 
 
 
 
 
                            // Replace water with grass after delay of 30 frames
                            if (cell.laserdelay >= 2) {
                            
                       
                        
                                cell.element = 'lava';
                                cell.laserdelay = 0;
                            }
                        }
            }
            if(cell.element==='lava'){
                const laseradjacentCells = [{
                                row: row - 1,
                                col: col
                            }
                        ];
                        const laserAdjacent = laseradjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'laser'
                        );
 
 
 
 
 
 
 
 
                        // If water is adjacent to grass, start or increment the delay
                        if (laserAdjacent) {
                            cell.laserdelay++;
 
 
 
 
 
 
 
 
                            // Replace water with grass after delay of 30 frames
                            if (cell.laserdelay >= 3) {
                            
                       
                        
                                cell.element = 'empty';
                                cell.laserdelay = 0;
                            }
                        }
            }
            if(elements[grid[row][col].element].flammable){
                const laseradjacentCells = [{
                                row: row - 1,
                                col: col
                            }, // Up
                            {
                                row: row + 1,
                                col: col
                            }, // Down
                            {
                                row: row,
                                col: col - 1
                            }, // Left
                            {
                                row: row,
                                col: col + 1
                            } // Right
                        ];
                        const laserAdjacent = laseradjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'laser'
                        );
 
 
 
 
 
 
 
 
                        // If water is adjacent to grass, start or increment the delay
                        if (laserAdjacent) {
                            cell.laserdelay++;
 
 
 
 
 
 
 
 
                            // Replace water with grass after delay of 30 frames
                            if (cell.laserdelay >= 1) {
                            
                       
                        
                                cell.element = 'fire';
                                cell.laserdelay = 0;
                            }
                        }
            }
            if(cell.element==='fire'){
                const laseradjacentCells = [{
                                row: row - 1,
                                col: col
                            }
                        ];
                        const laserAdjacent = laseradjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'laser'
                        );
 
 
 
 
 
 
 
 
                        // If water is adjacent to grass, start or increment the delay
                        if (laserAdjacent) {
                            cell.laserdelay++;
 
 
 
 
 
 
 
 
                            // Replace water with grass after delay of 30 frames
                            if (cell.laserdelay >= 1) {
                            
                       
                        
                                cell.element = 'empty';
                                cell.laserdelay = 0;
                            }
                        }
            }
            if(cell.element==='water'){
                const laseradjacentCells = [{
                                row: row - 1,
                                col: col
                            }, // Up
                            {
                                row: row + 1,
                                col: col
                            }, // Down
                            {
                                row: row,
                                col: col - 1
                            }, // Left
                            {
                                row: row,
                                col: col + 1
                            } // Right
                        ];
                        const laserAdjacent = laseradjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'laser'
                        );
 
 
 
 
 
 
 
 
                        // If water is adjacent to grass, start or increment the delay
                        if (laserAdjacent) {
                            cell.laserdelay++;
 
 
 
 
 
 
 
 
                            // Replace water with grass after delay of 30 frames
                            if (cell.laserdelay >= 2) {
                            
                       
                        
                                cell.element = 'steam';
                                cell.laserdelay = 0;
                            }
                        }
            }
            if(cell.element==='steam'){
                const laseradjacentCells = [{
                                row: row - 1,
                                col: col
                            }
                        ];
                        const laserAdjacent = laseradjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'laser'
                        );
 
 
 
 
 
 
 
 
                        // If water is adjacent to grass, start or increment the delay
                        if (laserAdjacent) {
                            cell.laserdelay++;
 
 
 
 
 
 
 
 
                            // Replace water with grass after delay of 30 frames
                            if (cell.laserdelay >= 0) {
                            
                       
                        
                                cell.element = 'empty';
                                cell.laserdelay = 0;
                            }
                        }
            }
            if(cell.element==='sand'){
                const laseradjacentCells = [{
                                row: row - 1,
                                col: col
                            }, // Up
                            {
                                row: row + 1,
                                col: col
                            }, // Down
                            {
                                row: row,
                                col: col - 1
                            }, // Left
                            {
                                row: row,
                                col: col + 1
                            } // Right
                        ];
                        const laserAdjacent = laseradjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'laser'
                        );
 
 
 
 
 
 
 
 
                        // If water is adjacent to grass, start or increment the delay
                        if (laserAdjacent) {
                            cell.laserdelay++;
 
 
 
 
 
 
 
 
                            // Replace water with grass after delay of 30 frames
                            if (cell.laserdelay >= 4) {
                            
                       
                        
                                cell.element = 'moltensand';
                                cell.laserdelay = 0;
                            }
                        }
            }
            if(cell.element==='moltensand'){
                const laseradjacentCells = [{
                                row: row - 1,
                                col: col
                            }
                        ];
                        const laserAdjacent = laseradjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'laser'
                        );
 
 
 
 
 
 
 
 
                        // If water is adjacent to grass, start or increment the delay
                        if (laserAdjacent) {
                            cell.laserdelay++;
 
 
 
 
 
 
 
 
                            // Replace water with grass after delay of 30 frames
                            if (cell.laserdelay >= 3) {
                            
                       
                        
                                cell.element = 'empty';
                                cell.laserdelay = 0;
                            }
                        }
            }
            if(cell.element==='mud'){
                const laseradjacentCells = [{
                                row: row - 1,
                                col: col
                            }, // Up
                            {
                                row: row + 1,
                                col: col
                            }, // Down
                            {
                                row: row,
                                col: col - 1
                            }, // Left
                            {
                                row: row,
                                col: col + 1
                            } // Right
                        ];
                        const laserAdjacent = laseradjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'laser'
                        );
 
 
 
 
 
 
 
 
                        // If water is adjacent to grass, start or increment the delay
                        if (laserAdjacent) {
                            cell.laserdelay++;
 
 
 
 
 
 
 
 
                            // Replace water with grass after delay of 30 frames
                            if (cell.laserdelay >= 2) {
                            
                       
                        
                                cell.element = 'dirt';
                                cell.laserdelay = 0;
                            }
                        }
            }
            if(cell.element==='dirt'){
                const laseradjacentCells = [{
                                row: row - 1,
                                col: col
                            }
                        ];
                        const laserAdjacent = laseradjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'laser'
                        );
 
 
 
 
 
 
 
 
                        // If water is adjacent to grass, start or increment the delay
                        if (laserAdjacent) {
                            cell.laserdelay++;
 
 
 
 
 
 
 
 
                            // Replace water with grass after delay of 30 frames
                            if (cell.laserdelay >= 5) {
                            
                       
                        
                                cell.element = 'magma';
                                cell.laserdelay = 0;
                            }
                        }
            }
            if(cell.element==='magma'){
                const laseradjacentCells = [{
                                row: row - 1,
                                col: col
                            }
                        ];
                        const laserAdjacent = laseradjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'laser'
                        );
 
 
 
 
 
 
 
 
                        // If water is adjacent to grass, start or increment the delay
                        if (laserAdjacent) {
                            cell.laserdelay++;
 
 
 
 
 
 
 
 
                            // Replace water with grass after delay of 30 frames
                            if (cell.laserdelay >= 2) {
                            
                       
                        
                                cell.element = 'empty';
                                cell.laserdelay = 0;
                            }
                        }
            }
            if(cell.element==='ice'){
                const laseradjacentCells = [{
                                row: row - 1,
                                col: col
                            }, // Up
                            {
                                row: row + 1,
                                col: col
                            }, // Down
                            {
                                row: row,
                                col: col - 1
                            }, // Left
                            {
                                row: row,
                                col: col + 1
                            } // Right
                        ];
                        const laserAdjacent = laseradjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'laser'
                        );
 
 
 
 
 
 
 
 
                        // If water is adjacent to grass, start or increment the delay
                        if (laserAdjacent) {
                            cell.laserdelay++;
 
 
 
 
 
 
 
 
                            // Replace water with grass after delay of 30 frames
                            if (cell.laserdelay >= 0) {
                            
                       
                        
                                cell.element = 'empty';
                                cell.laserdelay = 0;
                            }
                        }
            }
            if(cell.element==='snow'){
                const laseradjacentCells = [{
                                row: row - 1,
                                col: col
                            }, // Up
                            {
                                row: row + 1,
                                col: col
                            }, // Down
                            {
                                row: row,
                                col: col - 1
                            }, // Left
                            {
                                row: row,
                                col: col + 1
                            } // Right
                        ];
                        const laserAdjacent = laseradjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'laser'
                        );
 
 
 
 
 
 
 
 
                        // If water is adjacent to grass, start or increment the delay
                        if (laserAdjacent) {
                            cell.laserdelay++;
 
 
 
 
 
 
 
 
                            // Replace water with grass after delay of 30 frames
                            if (cell.laserdelay >= 1) {
                            
                       
                        
                                cell.element = 'water';
                                cell.laserdelay = 0;
                            }
                        }
            }
            if(cell.element==='glass'){
                const laseradjacentCells = [{
                                row: row - 1,
                                col: col
                            }, // Up
                            {
                                row: row + 1,
                                col: col
                            }, // Down
                            {
                                row: row,
                                col: col - 1
                            }, // Left
                            {
                                row: row,
                                col: col + 1
                            } // Right
                        ];
                        const laserAdjacent = laseradjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'laser'
                        );
 
 
 
 
 
 
 
 
                        // If water is adjacent to grass, start or increment the delay
                        if (laserAdjacent) {
                            cell.laserdelay++;
 
 
 
 
 
 
 
 
                            // Replace water with grass after delay of 30 frames
                            if (cell.laserdelay >= 3) {
                            
                       
                        
                                cell.element = 'moltensand';
                                cell.laserdelay = 0;
                            }
                        }
            }
            if(cell.element==='obsidian'){
                const laseradjacentCells = [{
                                row: row - 1,
                                col: col
                            }, // Up
                            {
                                row: row + 1,
                                col: col
                            }, // Down
                            {
                                row: row,
                                col: col - 1
                            }, // Left
                            {
                                row: row,
                                col: col + 1
                            } // Right
                        ];
                        const laserAdjacent = laseradjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'laser'
                        );
 
 
 
 
 
 
 
 
                        // If water is adjacent to grass, start or increment the delay
                        if (laserAdjacent) {
                            cell.laserdelay++;
 
 
 
 
 
 
 
 
                            // Replace water with grass after delay of 30 frames
                            if (cell.laserdelay >= 2) {
                            
                       
                        
                                cell.element = 'magma';
                                cell.laserdelay = 0;
                            }
                        }
            }
            if(cell.element==='concrete'){
                const laseradjacentCells = [{
                                row: row - 1,
                                col: col
                            }, // Up
                            {
                                row: row + 1,
                                col: col
                            }, // Down
                            {
                                row: row,
                                col: col - 1
                            }, // Left
                            {
                                row: row,
                                col: col + 1
                            } // Right
                        ];
                        const laserAdjacent = laseradjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'laser'
                        );
 
 
 
 
 
 
 
 
                        // If water is adjacent to grass, start or increment the delay
                        if (laserAdjacent) {
                            cell.laserdelay++;
 
 
 
 
 
 
 
 
                            // Replace water with grass after delay of 30 frames
                            if (cell.laserdelay >= 2) {
                            
                       
                        
                                cell.element = 'stone';
                                cell.laserdelay = -2;
                            }
                        }
            }
            if(cell.element==='sugar'){
                const laseradjacentCells = [{
                                row: row - 1,
                                col: col
                            }, // Up
                            {
                                row: row + 1,
                                col: col
                            }, // Down
                            {
                                row: row,
                                col: col - 1
                            }, // Left
                            {
                                row: row,
                                col: col + 1
                            } // Right
                        ];
                        const laserAdjacent = laseradjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'laser'
                        );
 
 
 
 
 
 
 
 
                        // If water is adjacent to grass, start or increment the delay
                        if (laserAdjacent) {
                            cell.laserdelay++;
 
 
 
 
 
 
 
 
                            // Replace water with grass after delay of 30 frames
                            if (cell.laserdelay >= 4) {
                            
                       
                        
                                cell.element = 'crystal';
                                cell.laserdelay = -2;
                            }
                        }
            }
            if(cell.element==='crystal'){
                const laseradjacentCells = [{
                                row: row - 1,
                                col: col
                            }, // Up
                            {
                                row: row + 1,
                                col: col
                            }, // Down
                            {
                                row: row,
                                col: col - 1
                            }, // Left
                            {
                                row: row,
                                col: col + 1
                            } // Right
                        ];
                        const laserAdjacent = laseradjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'laser'
                        );
 
 
 
 
 
 
 
 
                        // If water is adjacent to grass, start or increment the delay
                        if (laserAdjacent) {
                            cell.laserdelay++;
 
 
 
 
 
 
 
 
                            // Replace water with grass after delay of 30 frames
                            if (cell.laserdelay >= 3) {
                            
                       
                        
                                cell.element = 'lava';
                                cell.laserdelay = 0;
                            }
                        }
            }
            if(cell.element==='basalt'){
                const laseradjacentCells = [{
                                row: row - 1,
                                col: col
                            }, // Up
                            {
                                row: row + 1,
                                col: col
                            }, // Down
                            {
                                row: row,
                                col: col - 1
                            }, // Left
                            {
                                row: row,
                                col: col + 1
                            } // Right
                        ];
                        const laserAdjacent = laseradjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'laser'
                        );
 
 
 
 
 
 
 
 
                        // If water is adjacent to grass, start or increment the delay
                        if (laserAdjacent) {
                            cell.laserdelay++;
 
 
 
 
 
 
 
 
                            // Replace water with grass after delay of 30 frames
                            if (cell.laserdelay >= 2) {
                            
                       
                        
                                cell.element = 'magma';
                                cell.laserdelay = 0;
                            }
                        }
            }
            if(cell.element==='glitch'){
                const laseradjacentCells = [{
                                row: row - 1,
                                col: col
                            }
                        ];
                        const laserAdjacent = laseradjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'laser'
                        );
 
 
 
 
 
 
 
 
                        // If water is adjacent to grass, start or increment the delay
                        if (laserAdjacent) {
                            cell.laserdelay++;
 
 
 
 
 
 
 
 
                            // Replace water with grass after delay of 30 frames
                            if (cell.laserdelay >= 50) {
                            
                       
                        
                                cell.element = 'blackhole';
                                cell.laserdelay = 0;
                            }
                        }
            }
            if(cell.element==='blackhole'){
                const laseradjacentCells = [{
                                row: row - 1,
                                col: col
                            }
                        ];
                        const laserAdjacent = laseradjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'laser'
                        );
 
 
 
 
 
 
 
 
                        // If water is adjacent to grass, start or increment the delay
                        if (laserAdjacent) {
                            cell.laserdelay++;
 
 
 
 
 
 
 
 
                            // Replace water with grass after delay of 30 frames
                            if (cell.laserdelay >= 50) {
                            
                       
                        
                                cell.element = 'UExplosion';
                                cell.laserdelay = 0;
                            }
                        }
            }
            if(cell.element==='fly'){
                const laseradjacentCells = [{
                                row: row - 1,
                                col: col
                            }, // Up
                            {
                                row: row + 1,
                                col: col
                            }, // Down
                            {
                                row: row,
                                col: col - 1
                            }, // Left
                            {
                                row: row,
                                col: col + 1
                            } // Right
                        ];
                        const laserAdjacent = laseradjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'laser'
                        );
 
 
 
 
 
 
 
 
                        // If water is adjacent to grass, start or increment the delay
                        if (laserAdjacent) {
                            cell.laserdelay++;
 
 
 
 
 
 
 
 
                            // Replace water with grass after delay of 30 frames
                            if (cell.laserdelay >= 0) {
                            
                       
                        
                                cell.element = 'empty';
                                cell.laserdelay = 0;
                            }
                        }
            }
            if(cell.element==='ash'){
                const laseradjacentCells = [{
                                row: row - 1,
                                col: col
                            }
                        ];
                        const laserAdjacent = laseradjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'laser'
                        );
 
 
 
 
 
 
 
 
                        // If water is adjacent to grass, start or increment the delay
                        if (laserAdjacent) {
                            cell.laserdelay++;
 
 
 
 
 
 
 
 
                            // Replace water with grass after delay of 30 frames
                            if (cell.laserdelay >= 0) {
                            
                       
                        
                                cell.element = 'empty';
                                cell.laserdelay = 0;
                            }
                        }
            }
            if(cell.element==='liquidN'){
                const laseradjacentCells = [{
                                row: row - 1,
                                col: col
                            }, // Up
                            {
                                row: row + 1,
                                col: col
                            }, // Down
                            {
                                row: row,
                                col: col - 1
                            }, // Left
                            {
                                row: row,
                                col: col + 1
                            } // Right
                        ];
                        const laserAdjacent = laseradjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'laser'
                        );
 
 
 
 
 
 
 
 
                        // If water is adjacent to grass, start or increment the delay
                        if (laserAdjacent) {
                            cell.laserdelay++;
 
 
 
 
 
 
 
 
                            // Replace water with grass after delay of 30 frames
                            if (cell.laserdelay >= 2) {
                            
                       
                        
                                cell.element = 'ice';
                                cell.laserdelay = 0;
                            }
                        }
            }
            if(cell.element==='milk'){
                const laseradjacentCells = [{
                                row: row - 1,
                                col: col
                            }, // Up
                            {
                                row: row + 1,
                                col: col
                            }, // Down
                            {
                                row: row,
                                col: col - 1
                            }, // Left
                            {
                                row: row,
                                col: col + 1
                            } // Right
                        ];
                        const laserAdjacent = laseradjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'laser'
                        );
 
 
 
 
 
 
 
 
                        // If water is adjacent to grass, start or increment the delay
                        if (laserAdjacent) {
                            cell.laserdelay++;
 
 
 
 
 
 
 
 
                            // Replace water with grass after delay of 30 frames
                            if (cell.laserdelay >= 4) {
                            
                       
                        
                                cell.element = 'steam';
                                cell.laserdelay = 0;
                            }
                        }
            }
            if(cell.element==='steel'){
                const laseradjacentCells = [{
                                row: row - 1,
                                col: col
                            }, // Up
                            {
                                row: row + 1,
                                col: col
                            }, // Down
                            {
                                row: row,
                                col: col - 1
                            }, // Left
                            {
                                row: row,
                                col: col + 1
                            } // Right
                        ];
                        const laserAdjacent = laseradjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'laser'
                        );
 
 
 
 
 
 
 
 
                        // If water is adjacent to grass, start or increment the delay
                        if (laserAdjacent) {
                            cell.laserdelay++;
 
 
 
 
 
 
 
 
                            // Replace water with grass after delay of 30 frames
                            if (cell.laserdelay >= 2) {
                            
                       
                        
                                cell.element = 'rust';
                                cell.laserdelay = 0;
                            }
                        }
            }
            if(cell.element==='rust'){
                const laseradjacentCells = [{
                                row: row - 1,
                                col: col
                            }
                        ];
                        const laserAdjacent = laseradjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'laser'
                        );
 
 
 
 
 
 
 
 
                        // If water is adjacent to grass, start or increment the delay
                        if (laserAdjacent) {
                            cell.laserdelay++;
 
 
 
 
 
 
 
 
                            // Replace water with grass after delay of 30 frames
                            if (cell.laserdelay >= 2) {
                            
                       
                        
                                cell.element = 'magma';
                                cell.laserdelay = 0;
                            }
                        }
            }
            if(cell.element==='wetsponge'){
                const laseradjacentCells = [{
                                row: row - 1,
                                col: col
                            }, // Up
                            {
                                row: row + 1,
                                col: col
                            }, // Down
                            {
                                row: row,
                                col: col - 1
                            }, // Left
                            {
                                row: row,
                                col: col + 1
                            } // Right
                        ];
                        const laserAdjacent = laseradjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'laser'
                        );
 
 
 
 
 
 
 
 
                        // If water is adjacent to grass, start or increment the delay
                        if (laserAdjacent) {
                            cell.laserdelay++;
 
 
 
 
 
 
 
 
                            // Replace water with grass after delay of 30 frames
                            if (cell.laserdelay >= 2) {
                            
                       
                        
                                cell.element = 'sponge';
                                cell.laserdelay = 0;
                            }
                        }
            }
            if(cell.element==='salt'){
                const laseradjacentCells = [{
                                row: row - 1,
                                col: col
                            }, // Up
                            {
                                row: row + 1,
                                col: col
                            }, // Down
                            {
                                row: row,
                                col: col - 1
                            }, // Left
                            {
                                row: row,
                                col: col + 1
                            } // Right
                        ];
                        const laserAdjacent = laseradjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'laser'
                        );
 
 
 
 
 
 
 
 
                        // If water is adjacent to grass, start or increment the delay
                        if (laserAdjacent) {
                            cell.laserdelay++;
 
 
 
 
 
 
 
 
                            // Replace water with grass after delay of 30 frames
                            if (cell.laserdelay >= 3) {
                            
                       
                        
                                cell.element = 'crystal';
                                cell.laserdelay = 0;
                            }
                        }
            }
            if(cell.element==='quartz'){
                const laseradjacentCells = [{
                                row: row - 1,
                                col: col
                            }, // Up
                            {
                                row: row + 1,
                                col: col
                            }, // Down
                            {
                                row: row,
                                col: col - 1
                            }, // Left
                            {
                                row: row,
                                col: col + 1
                            } // Right
                        ];
                        const laserAdjacent = laseradjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'laser'
                        );
 
 
 
 
 
 
 
 
                        // If water is adjacent to grass, start or increment the delay
                        if (laserAdjacent) {
                            cell.laserdelay++;
 
 
 
 
 
 
 
 
                            // Replace water with grass after delay of 30 frames
                            if (cell.laserdelay >= 4) {
                            
                       
                        
                                cell.element = 'crystal';
                                cell.laserdelay = 0;
                            }
                        }
            }
            if(cell.element==='fog'){
                const laseradjacentCells = [{
                                row: row - 1,
                                col: col
                            }
                        ];
                        const laserAdjacent = laseradjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'laser'
                        );
 
 
 
 
 
 
 
 
                        // If water is adjacent to grass, start or increment the delay
                        if (laserAdjacent) {
                            cell.laserdelay++;
 
 
 
 
 
 
 
 
                            // Replace water with grass after delay of 30 frames
                            if (cell.laserdelay >= 0) {
                            
                       
                        
                                cell.element = 'empty';
                                cell.laserdelay = 0;
                            }
                        }
            }
            if(cell.element==='bone'){
                const laseradjacentCells = [{
                                row: row - 1,
                                col: col
                            }, // Up
                            {
                                row: row + 1,
                                col: col
                            }, // Down
                            {
                                row: row,
                                col: col - 1
                            }, // Left
                            {
                                row: row,
                                col: col + 1
                            } // Right
                        ];
                        const laserAdjacent = laseradjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'laser'
                        );
 
 
 
 
 
 
 
 
                        // If water is adjacent to grass, start or increment the delay
                        if (laserAdjacent) {
                            cell.laserdelay++;
 
 
 
 
 
 
 
 
                            // Replace water with grass after delay of 30 frames
                            if (cell.laserdelay >= 2) {
                            
                       
                        
                                cell.element = 'stone';
                                cell.laserdelay = 0;
                            }
                        }
            }
            if(cell.element==='copper'){
                const laseradjacentCells = [{
                                row: row - 1,
                                col: col
                            }, // Up
                            {
                                row: row + 1,
                                col: col
                            }, // Down
                            {
                                row: row,
                                col: col - 1
                            }, // Left
                            {
                                row: row,
                                col: col + 1
                            } // Right
                        ];
                        const laserAdjacent = laseradjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'laser'
                        );
 
 
 
 
 
 
 
 
                        // If water is adjacent to grass, start or increment the delay
                        if (laserAdjacent) {
                            cell.laserdelay++;
 
 
 
 
 
 
 
 
                            // Replace water with grass after delay of 30 frames
                            if (cell.laserdelay >= 4) {
                            
                       
                        
                                cell.element = 'copper2';
                                cell.laserdelay = 0;
                            }
                        }
            }
            if(cell.element==='copper2'){
                const laseradjacentCells = [{
                                row: row - 1,
                                col: col
                            }
                        ];
                        const laserAdjacent = laseradjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'laser'
                        );
 
 
 
 
 
 
 
 
                        // If water is adjacent to grass, start or increment the delay
                        if (laserAdjacent) {
                            cell.laserdelay++;
 
 
 
 
 
 
 
 
                            // Replace water with grass after delay of 30 frames
                            if (cell.laserdelay >= 3) {
                            
                       
                        
                                cell.element = 'copper3';
                                cell.laserdelay = 0;
                            }
                        }
            }
            if(cell.element==='copper3'){
                const laseradjacentCells = [{
                                row: row - 1,
                                col: col
                            }
                        ];
                        const laserAdjacent = laseradjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'laser'
                        );
 
 
 
 
 
 
 
 
                        // If water is adjacent to grass, start or increment the delay
                        if (laserAdjacent) {
                            cell.laserdelay++;
 
 
 
 
 
 
 
 
                            // Replace water with grass after delay of 30 frames
                            if (cell.laserdelay >= 3) {
                            
                       
                        
                                cell.element = 'copper4';
                                cell.laserdelay = 0;
                            }
                        }
            }
            if(cell.element==='copper4'){
                const laseradjacentCells = [{
                                row: row - 1,
                                col: col
                            }
                        ];
                        const laserAdjacent = laseradjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'laser'
                        );
 
 
 
 
 
 
 
 
                        // If water is adjacent to grass, start or increment the delay
                        if (laserAdjacent) {
                            cell.laserdelay++;
 
 
 
 
 
 
 
 
                            // Replace water with grass after delay of 30 frames
                            if (cell.laserdelay >= 3) {
                            
                       
                        
                                cell.element = 'copper5';
                                cell.laserdelay = 0;
                            }
                        }
            }
            if(cell.element==='copper5'){
                const laseradjacentCells = [{
                                row: row - 1,
                                col: col
                            }
                        ];
                        const laserAdjacent = laseradjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'laser'
                        );
 
 
 
 
 
 
 
 
                        // If water is adjacent to grass, start or increment the delay
                        if (laserAdjacent) {
                            cell.laserdelay++;
 
 
 
 
 
 
 
 
                            // Replace water with grass after delay of 30 frames
                            if (cell.laserdelay >= 3) {
                            
                       
                        
                                cell.element = 'empty';
                                cell.laserdelay = 0;
                            }
                        }
            }
            if(cell.element==='mercury'){
                const laseradjacentCells = [{
                                row: row - 1,
                                col: col
                            }, // Up
                            {
                                row: row + 1,
                                col: col
                            }, // Down
                            {
                                row: row,
                                col: col - 1
                            }, // Left
                            {
                                row: row,
                                col: col + 1
                            } // Right
                        ];
                        const laserAdjacent = laseradjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'laser'
                        );
 
 
 
 
 
 
 
 
                        // If water is adjacent to grass, start or increment the delay
                        if (laserAdjacent) {
                            cell.laserdelay++;
 
 
 
 
 
 
 
 
                            // Replace water with grass after delay of 30 frames
                            if (cell.laserdelay >= 5) {
                            
                       
                        
                                cell.element = 'steel';
                                cell.laserdelay = 0;
                            }
                        }
            }
            if(cell.element==='acid'){
                const laseradjacentCells = [{
                                row: row - 1,
                                col: col
                            }
                        ];
                        const laserAdjacent = laseradjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'laser'
                        );
 
 
 
 
 
 
 
 
                        // If water is adjacent to grass, start or increment the delay
                        if (laserAdjacent) {
                            cell.laserdelay++;
 
 
 
 
 
 
 
 
                            // Replace water with grass after delay of 30 frames
                            if (cell.laserdelay >= 2) {
                            
                       
                        
                                cell.element = 'empty';
                                cell.laserdelay = 0;
                            }
                        }
            }
            if(cell.element==='plastic'){
                const laseradjacentCells = [{
                                row: row - 1,
                                col: col
                            }, // Up
                            {
                                row: row + 1,
                                col: col
                            }, // Down
                            {
                                row: row,
                                col: col - 1
                            }, // Left
                            {
                                row: row,
                                col: col + 1
                            } // Right
                        ];
                        const laserAdjacent = laseradjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'laser'
                        );
 
 
 
 
 
 
 
 
                        // If water is adjacent to grass, start or increment the delay
                        if (laserAdjacent) {
                            cell.laserdelay++;
 
 
 
 
 
 
 
 
                            // Replace water with grass after delay of 30 frames
                            if (cell.laserdelay >= 2) {
                            
                       
                        
                                cell.element = 'pwater';
                                cell.laserdelay = 0;
                            }
                        }
            }
            if(cell.element==='pwater'){
                const laseradjacentCells = [{
                                row: row - 1,
                                col: col
                            }, // Up
                            {
                                row: row + 1,
                                col: col
                            }, // Down
                            {
                                row: row,
                                col: col - 1
                            }, // Left
                            {
                                row: row,
                                col: col + 1
                            } // Right
                        ];
                        const laserAdjacent = laseradjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'laser'
                        );
 
 
 
 
 
 
 
 
                        // If water is adjacent to grass, start or increment the delay
                        if (laserAdjacent) {
                            cell.laserdelay++;
 
 
 
 
 
 
 
 
                            // Replace water with grass after delay of 30 frames
                            if (cell.laserdelay >= 4) {
                            
                       
                        
                                cell.element = 'water';
                                cell.laserdelay = 0;
                            }
                        }
            }
            if(cell.element==='wetsand'){
                const laseradjacentCells = [{
                                row: row - 1,
                                col: col
                            }, // Up
                            {
                                row: row + 1,
                                col: col
                            }, // Down
                            {
                                row: row,
                                col: col - 1
                            }, // Left
                            {
                                row: row,
                                col: col + 1
                            } // Right
                        ];
                        const laserAdjacent = laseradjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'laser'
                        );
 
 
 
 
 
 
 
 
                        // If water is adjacent to grass, start or increment the delay
                        if (laserAdjacent) {
                            cell.laserdelay++;
 
 
 
 
 
 
 
 
                            // Replace water with grass after delay of 30 frames
                            if (cell.laserdelay >= 2) {
                            
                       
                        
                                cell.element = 'sand';
                                cell.laserdelay = 0;
                            }
                        }
            }
            if(cell.element==='saltwater'){
                const laseradjacentCells = [{
                                row: row - 1,
                                col: col
                            }, // Up
                            {
                                row: row + 1,
                                col: col
                            }, // Down
                            {
                                row: row,
                                col: col - 1
                            }, // Left
                            {
                                row: row,
                                col: col + 1
                            } // Right
                        ];
                        const laserAdjacent = laseradjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'laser'
                        );
 
 
 
 
 
 
 
 
                        // If water is adjacent to grass, start or increment the delay
                        if (laserAdjacent) {
                            cell.laserdelay++;
 
 
 
 
 
 
 
 
                            // Replace water with grass after delay of 30 frames
                            if (cell.laserdelay >= 2) {
                            
                       
                        
                                cell.element = 'salt';
                                cell.laserdelay = 0;
                            }
                        }
            }
            if(cell.element==='brick'){
                const laseradjacentCells = [{
                                row: row - 1,
                                col: col
                            }, // Up
                            {
                                row: row + 1,
                                col: col
                            }, // Down
                            {
                                row: row,
                                col: col - 1
                            }, // Left
                            {
                                row: row,
                                col: col + 1
                            } // Right
                        ];
                        const laserAdjacent = laseradjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'laser'
                        );
 
 
 
 
 
 
 
 
                        // If water is adjacent to grass, start or increment the delay
                        if (laserAdjacent) {
                            cell.laserdelay++;
 
 
 
 
 
 
 
 
                            // Replace water with grass after delay of 30 frames
                            if (cell.laserdelay >= 3) {
                            
                       
                        
                                cell.element = 'empty';
                                cell.laserdelay = 0;
                            }
                        }
            }
            if(cell.element==='liquidgallium'){
                const laseradjacentCells = [{
                                row: row - 1,
                                col: col
                            }, // Up
                            {
                                row: row + 1,
                                col: col
                            }, // Down
                            {
                                row: row,
                                col: col - 1
                            }, // Left
                            {
                                row: row,
                                col: col + 1
                            } // Right
                        ];
                        const laserAdjacent = laseradjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'laser'
                        );
 
 
 
 
 
 
 
 
                        // If water is adjacent to grass, start or increment the delay
                        if (laserAdjacent) {
                            cell.laserdelay++;
 
 
 
 
 
 
 
 
                            // Replace water with grass after delay of 30 frames
                            if (cell.laserdelay >= 2) {
                            
                       
                        
                                cell.element = 'empty';
                                cell.laserdelay = 0;
                            }
                        }
            }

 
                    if (cell.element === 'water') {
                        // Initialize delay counter if it doesn't exist
                        cell.delay++;
                        if (!cell.delay) cell.delay = 0;
 
 
 
 
 
 
 
 
                        // Define adjacent cells (up, down, left, right)
                        const adjacentCells = [{
                                row: row - 1,
                                col: col
                            }, // Up
                            {
                                row: row + 1,
                                col: col
                            }, // Down
                            {
                                row: row,
                                col: col - 1
                            }, // Left
                            {
                                row: row,
                                col: col + 1
                            } // Right
                        ];
 
                        // Check for adjacent grass cells
                        let grassAdjacent = adjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'grass'
                        );
 
 
 
 
 
 
 
 
                        // If water is adjacent to grass, start or increment the delay
                        if (grassAdjacent) {
                            cell.delay++;
 
 
 
 
 
 
 
 
                            // Replace water with grass after delay of 30 frames
                            if (cell.delay >= 30) {
                             if (Math.random() < 0.01) {
                       
                        
                                cell.element = 'grass';
                             }
                            }
                        } else {
                            // Reset delay if not adjacent to grass
                            cell.delay = 0;
                        }
 
 
 
 
 
 
 
 
                        // Water movement logic
                        if(cell.delay>=50){
                        if (row < rows - 1 && grid[row + 1][col].element === 'empty') {
                         if(cell.delay>=50){
                             cell.delay=0;
                            grid[row + 1][col].element = 'water';
                            cell.element = 'empty';
                         
                        }} else {
                            let leftSpread = col > 0 && grid[row][col - 1].element === 'empty';
                            let rightSpread = col < cols - 1 && grid[row][col + 1].element === 'empty';
 
 
 
 
 
 
 
 
                            if (leftSpread && rightSpread) {
                                if (Math.random() < 0.5) leftSpread = false;
                                else rightSpread = false;
                            }
 
 
 
 
 
 
 
 
                            if (leftSpread) {
                                grid[row][col - 1].element = 'water';
                                cell.element = 'empty';
                            } else if (rightSpread) {
                                grid[row][col + 1].element = 'water';
                                cell.element = 'empty';
                            }
                        }
                    }
                 }
                 if(cell.element === 'flashbang'){
                        cell.age++;
                        if(cell.age>=10){
                            cell.age=0;
                            cell.element='FExplosion';
                        }
                    }
                    if(cell.element === 'flash'){
                        cell.age++;
                        if(cell.age>=5){
                            cell.age=0;
                            cell.element='empty';
                        }
                    }
                    if(cell.element === 'FExplosion'){
                        cell.age++;
                        if(cell.age>=5){
                            cell.age=0;
                            cell.element='empty';
                        }
                    }
                    if (cell.element === 'flashbang' && row < rows - 1) {
                       
                       if (grid[row + 1][col].element === 'empty') {
                           grid[row + 1][col].element = 'flashbang';
                           cell.element = 'empty'; cell.age = 0;}
                      
                        else {
                           let leftSpread = col > 0 && grid[row + 1][col - 1].element === 'empty';
                           let rightSpread = col < cols - 1 && grid[row + 1][col + 1].element === 'empty';
                           if (leftSpread && rightSpread) {
                               if (Math.random() < 0.5) leftSpread = false;
                               else rightSpread = false;
                           }
                           if (leftSpread) {
                               grid[row + 1][col - 1].element = 'flashbang';
                               cell.element = 'empty';
                           } else if (rightSpread) {
                               grid[row + 1][col + 1].element = 'flashbang';
                               cell.element = 'empty';
                           }
                       }
                   }
                   if (cell.element === 'FExplosion') {
     const fexplosionRadius = 5; // Define the explosion radius
     const fstartRow = Math.max(0, row - fexplosionRadius);
     const fendRow = Math.min(rows - 1, row + fexplosionRadius);
     const fstartCol = Math.max(0, col - fexplosionRadius);
     const fendCol = Math.min(cols - 1, col + fexplosionRadius);
 
     // Set the center of the explosion to fire
     cell.element = 'flash'; // Set the center cell to fire
      cell.age=0;
     for (let r = fstartRow; r <= fendRow; r++) {
         for (let c = fstartCol; c <= fendCol; c++) {
             const fdistance = Math.sqrt((r - row) ** 2 + (c - col) ** 2); // Calculate the distance from the explosion center
             if (fdistance <= fexplosionRadius) {
                 // Check if the cell is TNT
                 if (grid[r][c] && grid[r][c].element === 'empty') {
                    
                    grid[r][c].element = 'flash'; // Ignite flammable material
                    grid[r][c].age = 0; // Initialize fire's age
                    
                }
             }
         }
     }
    
 }
 if(cell.element==='gallium'){
        const adjacentCells = [{
                                row: row - 1,
                                col: col
                            }, // Up
                            
                           
                        
                        ];
 
                        // Check for adjacent grass cells
                        let GMAdjacent = adjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element !== 'empty' && grid[r][c].element !== 'gallium' 
                        );
                   
                  if(GMAdjacent){
                   
                    if(cell.delay>=1){
                    cell.element='liquidgallium';
                  } cell.delay++;} 
                }
                if (cell.element === 'liquidgallium' && row < rows - 1) {
                     cell.age++;
                   
                        
                        if (grid[row + 1][col].element === 'empty') {
                         
                            
                            grid[row + 1][col].element = 'liquidgallium';
                            cell.element = 'empty';
                        
                        }  else {
                            let leftSpread = col > 0 && grid[row][col - 1].element === 'empty';
                            let rightSpread = col < cols - 1 && grid[row][col + 1].element === 'empty';
 
                            
                             
                            if (leftSpread && rightSpread) {
                                if (Math.random() < 0.5){     rightSpread = false;
                                }
                              
                                leftSpread = false;
                            }
                           
                            if (leftSpread) {
                                grid[row][col - 1].element = 'liquidgallium';
                                cell.element = 'empty';
                            } else if (rightSpread) {
                                grid[row][col + 1].element = 'liquidgallium';
                                cell.element = 'empty';
                            }
                         }
                     
                    }
 
                    // Handle water physics
                    if (cell.element === 'water' && row < rows - 1) {
                     cell.age++;
                   
                        
                        if (grid[row + 1][col].element === 'empty') {
                         
                            
                            grid[row + 1][col].element = 'water';
                            cell.element = 'empty';
                        
                        } else if (grid[row + 1][col].element === 'lava') {
 
                            grid[row + 1][col].element = 'stone';
                            
                            cell.element = 'empty';
                            
                        } else if (grid[row + 1][col].element === 'magma') {
                            grid[row + 1][col].element = 'obsidian';
                            cell.element = 'empty';
                        } else {
                            let leftSpread = col > 0 && grid[row][col - 1].element === 'empty';
                            let rightSpread = col < cols - 1 && grid[row][col + 1].element === 'empty';
 
                            
                             
                            if (leftSpread && rightSpread) {
                                if (Math.random() < 0.5){     rightSpread = false;
                                }
                              
                                leftSpread = false;
                            }
                           
                            if (leftSpread) {
                                grid[row][col - 1].element = 'water';
                                cell.element = 'empty';
                            } else if (rightSpread) {
                                grid[row][col + 1].element = 'water';
                                cell.element = 'empty';
                            }
                         }
                     
                    }
                  
  // Handle water physics
  if (cell.element === 'liquidN' && row < rows - 1) {
                     cell.age++;
                   
                        
                        if (grid[row + 1][col].element === 'empty') {
                         
                            
                            grid[row + 1][col].element = 'liquidN';
                            cell.element = 'empty';
                        
                        }  else {
                            let leftSpread = col > 0 && grid[row][col - 1].element === 'empty';
                            let rightSpread = col < cols - 1 && grid[row][col + 1].element === 'empty';
 
                            
                             
                            if (leftSpread && rightSpread) {
                                if (Math.random() < 0.5){     rightSpread = false;
                                }
                              
                                leftSpread = false;
                            }
                           
                            if (leftSpread) {
                                grid[row][col - 1].element = 'liquidN';
                                cell.element = 'empty';
                            } else if (rightSpread) {
                                grid[row][col + 1].element = 'liquidN';
                                cell.element = 'empty';
                            }
                         }
                     
                    }
                    if (cell.element === 'mercury' && row < rows - 1) {
                     cell.age++;
                   
                        
                        if (grid[row + 1][col].element === 'empty') {
                         
                            
                            grid[row + 1][col].element = 'mercury';
                            cell.element = 'empty';
                        
                        }  else {
                            let leftSpread = col > 0 && grid[row][col - 1].element === 'empty';
                            let rightSpread = col < cols - 1 && grid[row][col + 1].element === 'empty';
 
                            
                             
                            if (leftSpread && rightSpread) {
                                if (Math.random() < 0.5){     rightSpread = false;
                                }
                              
                                leftSpread = false;
                            }
                           
                            if (leftSpread) {
                                grid[row][col - 1].element = 'mercury';
                                cell.element = 'empty';
                            } else if (rightSpread) {
                                grid[row][col + 1].element = 'mercury';
                                cell.element = 'empty';
                            }
                         }
                     
                    }
                    if (cell.element === 'milk' && row < rows - 1) {
                     cell.age++;
                   
                        
                        if (grid[row + 1][col].element === 'empty') {
                         
                            
                            grid[row + 1][col].element = 'milk';
                            cell.element = 'empty';
                        
                        }  else {
                            let leftSpread = col > 0 && grid[row][col - 1].element === 'empty';
                            let rightSpread = col < cols - 1 && grid[row][col + 1].element === 'empty';
 
                            
                             
                            if (leftSpread && rightSpread) {
                                if (Math.random() < 0.5){     rightSpread = false;
                                }
                              
                                leftSpread = false;
                            }
                           
                            if (leftSpread) {
                                grid[row][col - 1].element = 'milk';
                                cell.element = 'empty';
                            } else if (rightSpread) {
                                grid[row][col + 1].element = 'milk';
                                cell.element = 'empty';
                            }
                         }
                     
                    }
                    if (cell.element === 'pwater' && row < rows - 1) {
                     cell.age++;
                   
                        
                        if (grid[row + 1][col].element === 'empty') {
                         
                            
                            grid[row + 1][col].element = 'pwater';
                            cell.element = 'empty';
                        
                        }  else {
                            let leftSpread = col > 0 && grid[row][col - 1].element === 'empty';
                            let rightSpread = col < cols - 1 && grid[row][col + 1].element === 'empty';
 
                            
                             
                            if (leftSpread && rightSpread) {
                                if (Math.random() < 0.5){     rightSpread = false;
                                }
                              
                                leftSpread = false;
                            }
                           
                            if (leftSpread) {
                                grid[row][col - 1].element = 'pwater';
                                cell.element = 'empty';
                            } else if (rightSpread) {
                                grid[row][col + 1].element = 'pwater';
                                cell.element = 'empty';
                            }
                         }
                     
                    }
                    if (cell.element === 'saltwater' && row < rows - 1) {
                     cell.age++;
                   
                        
                        if (grid[row + 1][col].element === 'empty') {
                         
                            
                            grid[row + 1][col].element = 'saltwater';
                            cell.element = 'empty';
                        
                        }  else {
                            let leftSpread = col > 0 && grid[row][col - 1].element === 'empty';
                            let rightSpread = col < cols - 1 && grid[row][col + 1].element === 'empty';
 
                            
                             
                            if (leftSpread && rightSpread) {
                                if (Math.random() < 0.5){     rightSpread = false;
                                }
                              
                                leftSpread = false;
                            }
                           
                            if (leftSpread) {
                                grid[row][col - 1].element = 'saltwater';
                                cell.element = 'empty';
                            } else if (rightSpread) {
                                grid[row][col + 1].element = 'saltwater';
                                cell.element = 'empty';
                            }
                         }
                     
                    }
                    if (cell.element === 'nitro' && row < rows - 1) {
                     cell.age++;
                   
                        
                        if (grid[row + 1][col].element === 'empty') {
                         
                            
                            grid[row + 1][col].element = 'nitro';
                            cell.element = 'empty';
                        
                        }  else {
                            let leftSpread = col > 0 && grid[row][col - 1].element === 'empty';
                            let rightSpread = col < cols - 1 && grid[row][col + 1].element === 'empty';
 
                            
                             
                            if (leftSpread && rightSpread) {
                                if (Math.random() < 0.5){     rightSpread = false;
                                }
                              
                                leftSpread = false;
                            }
                           
                            if (leftSpread) {
                                grid[row][col - 1].element = 'nitro';
                                cell.element = 'empty';
                            } else if (rightSpread) {
                                grid[row][col + 1].element = 'nitro';
                                cell.element = 'empty';
                            }
                         }
                     
                    }
                    if (cell.element === 'acid' && row < rows - 1) {
                     cell.age++;
                   
                        
                        if (grid[row + 1][col].element === 'empty') {
                         
                            
                            grid[row + 1][col].element = 'acid';
                            cell.element = 'empty';
                        
                        }  else {
                            let leftSpread = col > 0 && grid[row][col - 1].element === 'empty';
                            let rightSpread = col < cols - 1 && grid[row][col + 1].element === 'empty';
 
                            
                             
                            if (leftSpread && rightSpread) {
                                if (Math.random() < 0.5){     rightSpread = false;
                                }
                              
                                leftSpread = false;
                            }
                           
                            if (leftSpread) {
                                grid[row][col - 1].element = 'acid';
                                cell.element = 'empty';
                            } else if (rightSpread) {
                                grid[row][col + 1].element = 'acid';
                                cell.element = 'empty';
                            }
                         }
                     
                    }
 
                   if (cell.element==='dirt'){
                     const adjacentCellsd = [
                         { row: row + 1,
                                col: col
                            }, // down
                            {
                                row: row - 1,
                                col: col
                            }, // Up
                            {
                                row: row,
                                col: col - 1
                            }, // Left
                            {
                                row: row,
                                col: col + 1
                            } // Right
                        ];
                        let dirtAdjacent = adjacentCellsd.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'water');
                        if (dirtAdjacent) {
                            grid[row][col].element = 'mud';
 
                           
                        }
                   }
                   if (cell.element==='sand'){
                     const adjacentCellssa = [
                         { row: row + 1,
                                col: col
                            }, // down
                            {
                                row: row - 1,
                                col: col
                            }, // Up
                            {
                                row: row,
                                col: col - 1
                            }, // Left
                            {
                                row: row,
                                col: col + 1
                            } // Right
                        ];
                        let sandwAdjacent = adjacentCellssa.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'water');
                        if (sandwAdjacent) {
                            grid[row][col].element = 'wetsand';
 
                           
                        }
                   }
                    // Handle sand physics
                    if (cell.element === 'dirt' && row < rows - 1) {
                       
                        if (grid[row + 1][col].element === 'empty') {
                            grid[row + 1][col].element = 'dirt';
                            cell.element = 'empty'; }
                       
                         else {
                            let leftSpread = col > 0 && grid[row + 1][col - 1].element === 'empty';
                            let rightSpread = col < cols - 1 && grid[row + 1][col + 1].element === 'empty';
                            if (leftSpread && rightSpread) {
                                if (Math.random() < 0.5) leftSpread = false;
                                else rightSpread = false;
                            }
                            if (leftSpread) {
                                grid[row + 1][col - 1].element = 'dirt';
                                cell.element = 'empty';
                            } else if (rightSpread) {
                                grid[row + 1][col + 1].element = 'dirt';
                                cell.element = 'empty';
                            }
                        }
                    }
                    if (cell.element === 'salt' && row < rows - 1) {
                       
                       if (grid[row + 1][col].element === 'empty') {
                           grid[row + 1][col].element = 'salt';
                           cell.element = 'empty'; }
                      
                        else {
                           let leftSpread = col > 0 && grid[row + 1][col - 1].element === 'empty';
                           let rightSpread = col < cols - 1 && grid[row + 1][col + 1].element === 'empty';
                           if (leftSpread && rightSpread) {
                               if (Math.random() < 0.5) leftSpread = false;
                               else rightSpread = false;
                           }
                           if (leftSpread) {
                               grid[row + 1][col - 1].element = 'salt';
                               cell.element = 'empty';
                           } else if (rightSpread) {
                               grid[row + 1][col + 1].element = 'salt';
                               cell.element = 'empty';
                           }
                       }
                   }
                        // Handle sand physics
                        if (cell.element === 'cloner' && row < rows - 1) {
                       
                       if (grid[row + 1][col].element === 'empty') {
                           grid[row + 1][col].element = 'cloner';
                           cell.element = 'empty'; }
                      
                        else {
                           let leftSpread = col > 0 && grid[row + 1][col - 1].element === 'empty';
                           let rightSpread = col < cols - 1 && grid[row + 1][col + 1].element === 'empty';
                           if (leftSpread && rightSpread) {
                               if (Math.random() < 0.5) leftSpread = false;
                               else rightSpread = false;
                           }
                           if (leftSpread) {
                               grid[row + 1][col - 1].element = 'cloner';
                               cell.element = 'empty';
                           } else if (rightSpread) {
                               grid[row + 1][col + 1].element = 'cloner';
                               cell.element = 'empty';
                           }
                       }
                   }
 
                     // Handle sand physics
                     if (cell.element === 'sand' && row < rows - 1) {
                       
                       if (grid[row + 1][col].element === 'empty') {
                           grid[row + 1][col].element = 'sand';
                           cell.element = 'empty'; }
                      
                        else {
                           let leftSpread = col > 0 && grid[row + 1][col - 1].element === 'empty';
                           let rightSpread = col < cols - 1 && grid[row + 1][col + 1].element === 'empty';
                           if (leftSpread && rightSpread) {
                               if (Math.random() < 0.5) leftSpread = false;
                               else rightSpread = false;
                           }
                           if (leftSpread) {
                               grid[row + 1][col - 1].element = 'sand';
                               cell.element = 'empty';
                           } else if (rightSpread) {
                               grid[row + 1][col + 1].element = 'sand';
                               cell.element = 'empty';
                           }
                       }
                   }
                    if (cell.element === 'grenade' && row < rows - 1) {
                       
                       if (grid[row + 1][col].element === 'empty') {
                           grid[row + 1][col].element = 'grenade';
                           cell.element = 'empty'; }
                      
                        else {
                           let leftSpread = col > 0 && grid[row + 1][col - 1].element === 'empty';
                           let rightSpread = col < cols - 1 && grid[row + 1][col + 1].element === 'empty';
                           if (leftSpread && rightSpread) {
                               if (Math.random() < 0.5) leftSpread = false;
                               else rightSpread = false;
                           }
                           if (leftSpread) {
                               grid[row + 1][col - 1].element = 'grenade';
                               cell.element = 'empty';
                           } else if (rightSpread) {
                               grid[row + 1][col + 1].element = 'grenade';
                               cell.element = 'empty';
                           }
                       }
                   }
                   
                   if (cell.element === 'gunpowder' && row < rows - 1) {
                       
                       if (grid[row + 1][col].element === 'empty') {
                           grid[row + 1][col].element = 'gunpowder';
                           cell.element = 'empty'; }
                      
                        else {
                           let leftSpread = col > 0 && grid[row + 1][col - 1].element === 'empty';
                           let rightSpread = col < cols - 1 && grid[row + 1][col + 1].element === 'empty';
                           if (leftSpread && rightSpread) {
                               if (Math.random() < 0.5) leftSpread = false;
                               else rightSpread = false;
                           }
                           if (leftSpread) {
                               grid[row + 1][col - 1].element = 'gunpowder';
                               cell.element = 'empty';
                           } else if (rightSpread) {
                               grid[row + 1][col + 1].element = 'gunpowder';
                               cell.element = 'empty';
                           }
                       }
                   }
                    if (cell.element === 'smokeBomb' && row < rows - 1) {
                       
                       if (grid[row + 1][col].element === 'empty') {
                           grid[row + 1][col].element = 'smokeBomb';
                           cell.element = 'empty'; }
                      
                        else {
                           let leftSpread = col > 0 && grid[row + 1][col - 1].element === 'empty';
                           let rightSpread = col < cols - 1 && grid[row + 1][col + 1].element === 'empty';
                           if (leftSpread && rightSpread) {
                               if (Math.random() < 0.5) leftSpread = false;
                               else rightSpread = false;
                           }
                           if (leftSpread) {
                               grid[row + 1][col - 1].element = 'smokeBomb';
                               cell.element = 'empty';
                           } else if (rightSpread) {
                               grid[row + 1][col + 1].element = 'smokeBomb';
                               cell.element = 'empty';
                           }
                       }
                   }
                   if (cell.element === 'sawdust' && row < rows - 1) {
                       
                       if (grid[row + 1][col].element === 'empty') {
                           grid[row + 1][col].element = 'sawdust';
                           cell.element = 'empty'; }
                      
                        else {
                           let leftSpread = col > 0 && grid[row + 1][col - 1].element === 'empty';
                           let rightSpread = col < cols - 1 && grid[row + 1][col + 1].element === 'empty';
                           if (leftSpread && rightSpread) {
                               if (Math.random() < 0.5) leftSpread = false;
                               else rightSpread = false;
                           }
                           if (leftSpread) {
                               grid[row + 1][col - 1].element = 'sawdust';
                               cell.element = 'empty';
                           } else if (rightSpread) {
                               grid[row + 1][col + 1].element = 'sawdust';
                               cell.element = 'empty';
                           }
                       }
                   }
                    if (cell.element === 'smokeBomb' && row < rows - 1) {
                       
                       if (grid[row + 1][col].element === 'empty') {
                           grid[row + 1][col].element = 'smokeBomb';
                           cell.element = 'empty'; }
                      
                        else {
                           let leftSpread = col > 0 && grid[row + 1][col - 1].element === 'empty';
                           let rightSpread = col < cols - 1 && grid[row + 1][col + 1].element === 'empty';
                           if (leftSpread && rightSpread) {
                               if (Math.random() < 0.5) leftSpread = false;
                               else rightSpread = false;
                           }
                           if (leftSpread) {
                               grid[row + 1][col - 1].element = 'smokeBomb';
                               cell.element = 'empty';
                           } else if (rightSpread) {
                               grid[row + 1][col + 1].element = 'smokeBomb';
                               cell.element = 'empty';
                           }
                       }
                   }
   // Handle sand physics
   
 
                      if (cell.element==='concrete'){
                         cell.delay++;
                        
                        
                        
                         if(cell.delay>=200){
                             if (Math.random() < 0.08) {
                             cell.element='stone';
                             }
                         }
                      }
        
                    // Handle sand physics
                    if (cell.element === 'concrete' && row < rows - 1) {
                     
                        if (grid[row + 1][col].element === 'empty') {
                            grid[row + 1][col].element = 'concrete';
                            cell.element = 'empty'; }
                       
                         else {
                            let leftSpread = col > 0 && grid[row + 1][col - 1].element === 'empty';
                            let rightSpread = col < cols - 1 && grid[row + 1][col + 1].element === 'empty';
                            if (leftSpread && rightSpread) {
                                if (Math.random() < 0.5) leftSpread = false;
                                else rightSpread = false;
                            }
                            if (leftSpread) {
                                grid[row + 1][col - 1].element = 'concrete';
                                cell.element = 'empty';
                            } else if (rightSpread) {
                                grid[row + 1][col + 1].element = 'concrete';
                                cell.element = 'empty';
                            }
                        }
                     }                
                        
                    
 
 
 
                     if (cell.element==='human' && row < rows - 1){
                         if (grid[row + 1][col].element === 'oil') {
                            grid[row + 1][col].element = 'human';
                            cell.element = 'empty';
                            // Push water up
                            if (row > 0 && grid[row - 1][col].element === 'empty') {
                                grid[row - 1][col].element = 'oil';
                            }
                        
                        } 
                     }
 
                     if (cell.element==='human' && row < rows - 1){
                         if (grid[row + 1][col].element === 'syrup') {
                            grid[row + 1][col].element = 'human';
                            cell.element = 'empty';
                            // Push water up
                            if (row > 0 && grid[row - 1][col].element === 'empty') {
                                grid[row - 1][col].element = 'syrup';
                            }
                        
                        } 
                     }
                     if (cell.element==='human' && row < rows - 1){
                         if (grid[row + 1][col].element === 'water') {
                            grid[row + 1][col].element = 'human';
                            cell.element = 'empty';
                            // Push water up
                            if (row > 0 && grid[row - 1][col].element === 'empty') {
                                grid[row - 1][col].element = 'water';
                            }
                        
                        } 
                     }
 
                    // Handle sand physics
                    if (cell.element === 'sand' && row < rows - 1 ) {
                        const adjacentCellss = [{
                                row: row + 1,
                                col: col
                            }, // Down
                            {
                                row: row - 1,
                                col: col
                            }, // Up
                            {
                                row: row,
                                col: col - 1
                            }, // Left
                            {
                                row: row,
                                col: col + 1
                            } // Right
                        ];
                        let SandAdjacent = adjacentCellss.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'lava');
                        if (SandAdjacent) {
                            grid[row][col].element = 'moltensand';
                        }
                       
                        if (grid[row + 1][col].element === 'empty') {
                         
                            grid[row + 1][col].element = 'sand';
                            cell.element = 'empty';
                         
                        }  else if (grid[row + 1][col].element === 'water') {
                            grid[row + 1][col].element = 'sand';
                            cell.element = 'empty';
                            // Push water up
                            if (row > 0 && grid[row - 1][col].element === 'empty') {
                                grid[row - 1][col].element = 'water';
                            }
                        
                        } else if (grid[row + 1][col].element === 'lava') {
                            grid[row + 1][col].element = 'sand';
                            cell.element = 'empty';
                            // Push water up
                            if (row > 0 && grid[row - 1][col].element === 'empty') {
                                grid[row - 1][col].element = 'lava';
                            }  
                           
                          }   else if (grid[row + 1][col].element === 'moltensand') {
                                grid[row + 1][col].element = 'sand';
                                cell.element = 'empty';
                                // Push water up
                            }
                             else {
                            let leftSpread = col > 0 && grid[row + 1][col - 1].element === 'empty';
                            let rightSpread = col < cols - 1 && grid[row + 1][col + 1].element === 'empty';
                            if (leftSpread && rightSpread) {
                                if (Math.random() < 0.5) leftSpread = false;
                                else rightSpread = false;
                            }
                            if (leftSpread) {
                                grid[row + 1][col - 1].element = 'sand';
                                cell.element = 'empty';
                            } else if (rightSpread) {
                                grid[row + 1][col + 1].element = 'sand';
                                cell.element = 'empty';
                            }
                        }
                    }
                  
                 
                    if (cell.element === 'sugar' && row < rows - 1) {
                     const adjacentCells = [{
                                row: row + 1,
                                col: col
                            }, // Down
                            {
                                row: row - 1,
                                col: col
                            }, // Up
                            {
                                row: row,
                                col: col - 1
                            }, // Left
                            {
                                row: row,
                                col: col + 1
                            } // Right
                        ];
                        // Check for adjacent water
                        let sAdjacent = adjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'water'
                        );
                        // Transform dark lava into stone if adjacent to water
                        if (sAdjacent) {
                            grid[row][col].element = 'syrup';
                        }
                        if (grid[row + 1][col].element === 'empty') {
                            grid[row + 1][col].element = 'sugar';
                            cell.element = 'empty';
                        } else if (grid[row + 1][col].element === 'water') {
                            grid[row + 1][col].element = 'sugar';
                            cell.element = 'empty';
                            // Push water up
                            if (row > 0 && grid[row - 1][col].element === 'empty') {
                                grid[row - 1][col].element = 'water';
                            }
                        } else {
                            let leftSpread = col > 0 && grid[row + 1][col - 1].element === 'empty';
                            let rightSpread = col < cols - 1 && grid[row + 1][col + 1].element === 'empty';
                            if (leftSpread && rightSpread) {
                                if (Math.random() < 0.5) leftSpread = false;
                                else rightSpread = false;
                            }
                            if (leftSpread) {
                                grid[row + 1][col - 1].element = 'sugar';
                                cell.element = 'empty';
                            } else if (rightSpread) {
                                grid[row + 1][col + 1].element = 'sugar';
                                cell.element = 'empty';
                            }
                        }
                    }
 
 
 
 
 
 
 
 
 
                    if (cell.element === 'salt' ) {
                     const adjacentCells = [{
                                row: row + 1,
                                col: col
                            }, // Down
                            {
                                row: row - 1,
                                col: col
                            }, // Up
                            {
                                row: row,
                                col: col - 1
                            }, // Left
                            {
                                row: row,
                                col: col + 1
                            } // Right
                        ];
                        // Check for adjacent water
                        let saltAdjacent = adjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'water'
                        );
                        // Transform dark lava into stone if adjacent to water
                        if (saltAdjacent) {
                            grid[row][col].element = 'saltwater';
                        }}
                        if (cell.element === 'water' ) {
                     const adjacentCells = [{
                                row: row + 1,
                                col: col
                            }, // Down
                            {
                                row: row - 1,
                                col: col
                            }, // Up
                            {
                                row: row,
                                col: col - 1
                            }, // Left
                            {
                                row: row,
                                col: col + 1
                            } // Right
                        ];
                        // Check for adjacent water
                        let pwAdjacent = adjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'ash' 
                        );
                        // Transform dark lava into stone if adjacent to water
                        if (pwAdjacent) {
                            grid[row][col].element = 'pwater';
                        }}
                      
                 
                    if (cell.element === 'uranium') {
     
     const adjacentCells = [{
                                row: row + 1,
                                col: col
                            }, // Down
                            {
                                row: row - 1,
                                col: col
                            }, // Up
                            {
                                row: row,
                                col: col - 1
                            }, // Left
                            {
                                row: row,
                                col: col + 1
                            } // Right
                        ];
                        // Check for adjacent water
                        let pwAdjacent = adjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'water' 
                        );
                        // Transform dark lava into stone if adjacent to water
                        if (pwAdjacent) {
                           
                        } else cell.age++;
     if (cell.age < 100) {
         cell.uraniumColor = `rgba(0, 204, 0, ${1 - cell.age / 100})`;
     } else if (cell.age === 100) {
         cell.element = 'UExplosion';
       
         cell.uraniumColor = '#BC5800';
     }
 }
 if (cell.element === 'brick') {
     
     const adjacentCells = [{
                                row: row + 1,
                                col: col
                            }, // Down
                            {
                                row: row - 1,
                                col: col
                            }, // Up
                            {
                                row: row,
                                col: col - 1
                            }, // Left
                            {
                                row: row,
                                col: col + 1
                            } // Right
                        ];
                        // Check for adjacent water
                        const Adjacent = adjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'empty' 
                        );
                        // Transform dark lava into stone if adjacent to water
                        if (Adjacent) {
                           cell.brickColor = '#D4D4D4';
                        } else cell.brickColor = '#D12A2A';
   
 }
             
                    // Update Lava Cooling Process
                    if (cell.element === 'lava') {
                        cell.age++;
                        if (cell.age > 500) {} else if (row < rows - 1 && grid[row + 1][col].element === 'empty') {}
                    } else if (cell.element === 'darkLava') {
                        const adjacentCells = [{
                                row: row + 1,
                                col: col
                            }, // Down
                            {
                                row: row - 1,
                                col: col
                            }, // Up
                            {
                                row: row,
                                col: col - 1
                            }, // Left
                            {
                                row: row,
                                col: col + 1
                            } // Right
                        ];
                        // Check for adjacent water
                        let waterAdjacent = adjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'water'
                        );
                        // Transform dark lava into stone if adjacent to water
                        if (waterAdjacent) {
                            grid[row][col].element = 'stone';
                        }
                    }
                    if (cell.age > 2050) {} else // Additional Steam Behavior
                        if (cell.element === 'magma') {
                      
                            const adjacentCells = [{
                                    row: row - 1,
                                    col: col
                                }, // Up
                                {
                                    row: row + 1,
                                    col: col
                                }, // Down
                                {
                                    row: row,
                                    col: col - 1
                                }, // Left
                                {
                                    row: row,
                                    col: col + 1
                                } // Right
                            ];
                         
                            // Check for adjacent water cells
                            let waterAdjacent = adjacentCells.some(({
                                    row: r,
                                    col: c
                                }) =>
                                grid[r] && grid[r][c] && grid[r][c].element === 'water'
                            );
                            if (waterAdjacent) {
                                // Transform adjacent water into steam
                                adjacentCells.forEach(({
                                    row: r,
                                    col: c
                                }) => {
                                    if (grid[r] && grid[r][c] && grid[r][c].element === 'water') {
                                        grid[r][c].element = 'steam';
                                        cell.element = 'obsidian'
                                        grid[r][c].age = 0; // Initialize age for steam
                                    }
                                });
                            }
                        }
                        if(cell.element==='cactus' && row < rows -1 ){
 
                         if (grid[row + 1][col].element === 'empty') {
                            grid[row + 1][col].element = 'cactus';
                            cell.element = 'empty'; 
                         }
 
                        }
                    // Handle Steam Physics
                    if (cell.element === 'Explosion') {
     const explosionRadius = 5; // Define the explosion radius
     const startRow = Math.max(0, row - explosionRadius);
     const endRow = Math.min(rows - 1, row + explosionRadius);
     const startCol = Math.max(0, col - explosionRadius);
     const endCol = Math.min(cols - 1, col + explosionRadius);
 
     // Set the center of the explosion to fire
     cell.element = 'fire'; // Set the center cell to fire
      cell.age=0;
     for (let r = startRow; r <= endRow; r++) {
         for (let c = startCol; c <= endCol; c++) {
             const distance = Math.sqrt((r - row) ** 2 + (c - col) ** 2); // Calculate the distance from the explosion center
             if (distance <= explosionRadius) {
                 // Check if the cell is TNT
                 if (grid[r][c] && grid[r][c].element === 'uranium') {
                     grid[r][c].element = 'uranium'; // Change TNT to Explosion
                     grid[r][c].element = 'UExplosion'; // Change TNT to Explosion
                 } else  if (grid[r][c] && grid[r][c].element === 'gunpowder') {
                    
                     grid[r][c].element = 'Explosion'; // Change TNT to Explosion
                 } else
                 if (grid[r][c] && grid[r][c].element === 'tnt') {
                     grid[r][c].element = 'Explosion'; // Change TNT to Explosion
                  
                 
                 } else if (grid[r][c] && elements[grid[r][c].element]) {
                     grid[r][c].element = 'fire'; // Ignite flammable material
                     grid[r][c].age = 0; // Initialize fire's age
                 }
             }
         }
     }
     cell.element = 'empty'; // Remove the explosion after it has done its effect
 }
 if (cell.element === 'nb') {
     const nexplosionRadius = 5; // Define the explosion radius
     const nstartRow = Math.max(0, row - nexplosionRadius);
     const nendRow = Math.min(rows - 1, row + nexplosionRadius);
     const nstartCol = Math.max(0, col - nexplosionRadius);
     const nendCol = Math.min(cols - 1, col + nexplosionRadius);
 
     // Set the center of the explosion to fire
     cell.element = 'fire'; // Set the center cell to fire
      cell.age=0;
     for (let r = nstartRow; r <= nendRow; r++) {
         for (let c = nstartCol; c <= nendCol; c++) {
             const ndistance = Math.sqrt((r - row) ** 2 + (c - col) ** 2); // Calculate the distance from the explosion center
             if (ndistance <= nexplosionRadius) {
                 // Check if the cell is TNT
                 if (grid[r][c] && grid[r][c].element === 'uranium') {
                     grid[r][c].element = 'uranium'; // Change TNT to Explosion
                     grid[r][c].element = 'UExplosion'; // Change TNT to Explosion
                 } else  if (grid[r][c] && grid[r][c].element === 'gunpowder') {
                    
                     grid[r][c].element = 'Explosion'; // Change TNT to Explosion
                 } else
                 if (grid[r][c] && grid[r][c].element === 'tnt') {
                     grid[r][c].element = 'Explosion'; // Change TNT to Explosion
                  
                 
                 } else
                 if (grid[r][c] && grid[r][c].element === 'nitro') {
                     grid[r][c].element = 'nb'; // Change TNT to Explosion
                  
                 
                 }else if (grid[r][c] && elements[grid[r][c].element]) {
                     grid[r][c].element = 'fire'; // Ignite flammable material
                     grid[r][c].age = 0; // Initialize fire's age
                 }
             }
         }
     }
     cell.element = 'empty'; // Remove the explosion after it has done its effect
 }                      
 if (cell.element === 'UExplosion') {
     const UexplosionRadius = 15; // Define the explosion radius
     const ustartRow = Math.max(0, row - UexplosionRadius);
     const uendRow = Math.min(rows - 1, row + UexplosionRadius);
     const ustartCol = Math.max(0, col - UexplosionRadius);
     const uendCol = Math.min(cols - 1, col + UexplosionRadius);
 
     // Set the center of the explosion to fire
     cell.element = 'fire'; // Set the center cell to fire
      cell.age=0;
     for (let r = ustartRow; r <= uendRow; r++) {
         for (let c = ustartCol; c <= uendCol; c++) {
             const udistance = Math.sqrt((r - row) ** 2 + (c - col) ** 2); // Calculate the distance from the explosion center
             if (udistance <= UexplosionRadius) {
                 // Check if the cell is TNT
                 if (grid[r][c] && grid[r][c].element === 'uranium') {
                     grid[r][c].element = 'uranium'; // Change TNT to Explosion
                     grid[r][c].element = 'UExplosion'; // Change TNT to Explosion
                 } else
                 if (grid[r][c] && grid[r][c].element === 'tnt') {
                     grid[r][c].element = 'Explosion'; // Change TNT to Explosion
                  
                 
                 } else if (grid[r][c] && elements[grid[r][c].element]) {
                     grid[r][c].element = 'fire'; // Ignite flammable material
                     grid[r][c].age = 0; // Initialize fire's age
                 } 
             }
         }
     }
  
     cell.element = 'empty'; // Remove the explosion after it has done its effect
 }
 if (cell.element === 'blackhole') {
     const bexplosionRadius = 2; // Define the explosion radius
     const bstartRow = Math.max(0, row - bexplosionRadius);
     const bendRow = Math.min(rows - 1, row + bexplosionRadius);
     const bstartCol = Math.max(0, col - bexplosionRadius);
     const bendCol = Math.min(cols - 1, col + bexplosionRadius);
 
     // Set the center of the explosion to fire
    
    
     for (let r = bstartRow; r <= bendRow; r++) {
         for (let c = bstartCol; c <= bendCol; c++) {
             const bdistance = Math.sqrt((r - row) ** 2 + (c - col) ** 2); // Calculate the distance from the explosion center
             if (bdistance <= bexplosionRadius) {
                 // Check if the cell is TNT
              
                 cell.element='blackhole';
                 if (grid[r][c] && elements[grid[r][c].element]) {
                     grid[r][c].element = 'empty'; // Ignite flammable material
                     grid[r][c].age = 0; // Initialize fire's age
                 }
             }
         }
     }
    
 }
 if(cell.element==='grenade'){
     cell.delay++;
     if(cell.delay>=30){
         cell.element='Gexplosion';
         cell.delay=0;
     }
 }
 if (cell.element === 'Gexplosion') {
     const GexplosionRadius = 3; // Define the explosion radius
     const GstartRow = Math.max(0, row - GexplosionRadius);
     const GendRow = Math.min(rows - 1, row + GexplosionRadius);
     const GstartCol = Math.max(0, col - GexplosionRadius);
     const GendCol = Math.min(cols - 1, col + GexplosionRadius);
 
     // Set the center of the explosion to fire
     cell.element = 'fire'; // Set the center cell to fire
      cell.age=0;
     for (let r = GstartRow; r <= GendRow; r++) {
         for (let c = GstartCol; c <= GendCol; c++) {
             const Gdistance = Math.sqrt((r - row) ** 2 + (c - col) ** 2); // Calculate the distance from the explosion center
             if (Gdistance <= GexplosionRadius) {
                 // Check if the cell is TNT
                 if (grid[r][c] && grid[r][c].element === 'uranium') {
                     grid[r][c].element = 'uranium'; // Change TNT to Explosion
                     grid[r][c].element = 'UExplosion'; // Change TNT to Explosion
                 } else
                 if (grid[r][c] && grid[r][c].element === 'tnt') {
                     grid[r][c].element = 'Explosion'; // Change TNT to Explosion
                  
                 
                 } else  if (grid[r][c] && grid[r][c].element === 'gunpowder') {
                    
                    grid[r][c].element = 'Explosion'; // Change TNT to Explosion
                } else if (grid[r][c] && grid[r][c].element === 'human') {
                     grid[r][c].element = 'ash'; // Change TNT to Explosion
                  
                 
                 } else if (grid[r][c] && elements[grid[r][c].element]) {
                     grid[r][c].element = 'fire'; // Ignite flammable material
                     grid[r][c].age = 0; // Initialize fire's age
                 }
             }
         }
     }
     cell.element = 'empty'; // Remove the explosion after it has done its effect
 }
 if (cell.element === 'acid') {
                 // Increment the delay for acid
                 cell.delay++;
 
                 // Check adjacent cells
                 const adjacentCells = [
                     { row: row - 1, col: col }, // Up
                     { row: row + 1, col: col }, // Down
                     { row: row, col: col - 1 }, // Left
                     { row: row, col: col + 1 }  // Right
                 ];
 
                 // If delay reaches a certain threshold, destroy adjacent elements
                 if (cell.delay >= 15) { // Adjust this number for delay (60 frames = 1 second at 60fps)
                     adjacentCells.forEach(({ row: r, col: c }) => {
                         if (grid[r] && grid[r][c] && grid[r][c].element !== 'acid') {
                             grid[r][c].element = 'empty'; // Destroy the material
                         }
                     });
                     cell.delay = 0; // Reset the delay after destruction
                 }
             }
 if (cell.element === 'smokeBomb') {
     cell.delay++;
 
     const sexplosionRadius = 5; // Define the explosion radius
     const sstartRow = Math.max(0, row - sexplosionRadius);
     const sendRow = Math.min(rows - 1, row + sexplosionRadius);
     const sstartCol = Math.max(0, col - sexplosionRadius);
     const sendCol = Math.min(cols - 1, col + sexplosionRadius);
 
     // Set the center of the explosion to fire
     if(cell.delay>=20){
     cell.element = 'smoke'; // Set the center cell to fire
      cell.age=0;
     
     for (let r = sstartRow; r <= sendRow; r++) {
         for (let c = sstartCol; c <= sendCol; c++) {
             const sdistance = Math.sqrt((r - row) ** 2 + (c - col) ** 2); // Calculate the distance from the explosion center
             if (sdistance <= sexplosionRadius) {
                 // Check if the cell is TNT
                 
                  if (grid[r][c] && grid[r][c].element === 'empty') {
                    
                     grid[r][c].element = 'smoke'; // Ignite flammable material
                     grid[r][c].age = 0; // Initialize fire's age
                     
                 }
             }
         }
     }
     cell.element = 'empty'; // Remove the explosion after it has done its effect
 }
 }
 if (cell.element === 'magma') {
                      
                      const adjacentCells = [{
                              row: row - 1,
                              col: col
                          }, // Up
                          {
                              row: row + 1,
                              col: col
                          }, // Down
                          {
                              row: row,
                              col: col - 1
                          }, // Left
                          {
                              row: row,
                              col: col + 1
                          } // Right
                      ];
                          adjacentCells.forEach(({ row: r, col: c }) => {
         if (grid[r] && grid[r][c] && elements[grid[r][c].element].flammable) {
             grid[r][c].element = 'fire'; // Ignite flammable material
             grid[r][c].age = 0; // Initialize fire's age
         }
     });
    }
                      if (cell.element === 'stone') {
                      
                      const adjacentCells = [{
                              row: row - 1,
                              col: col
                          }, // Up
                          {
                              row: row + 1,
                              col: col
                          }, // Down
                          {
                              row: row,
                              col: col - 1
                          }, // Left
                          {
                              row: row,
                              col: col + 1
                          } // Right
                      ];
                    
                      // Check for adjacent water cells
                      let lavaAdjacents = adjacentCells.some(({
                              row: r,
                              col: c
                          }) =>
                          grid[r] && grid[r][c] && grid[r][c].element === 'lava'
                      );
                     
                      if (lavaAdjacents) {
                          // Transform adjacent water into steam
                          adjacentCells.forEach(({
                              row: r,
                              col: c
                          }) => {
                             
                              if (grid[r] && grid[r][c] && grid[r][c].element === 'lava') {
                                 cell.age++;
                                 if (cell.age >= 1000){
                                 
                                  cell.element = 'lowheatrock'
                                  } 
                              
                             }
 
                          });
                      }else{if (cell.age>0){cell.age--;}}}
                      if (cell.element === 'lowheatrock') {
                      
                      const adjacentCells = [{
                              row: row - 1,
                              col: col
                          }, // Up
                          {
                              row: row + 1,
                              col: col
                          }, // Down
                          {
                              row: row,
                              col: col - 1
                          }, // Left
                          {
                              row: row,
                              col: col + 1
                          } // Right
                      ];
                   
                      // Check for adjacent water cells
                      let lavaAdjacents = adjacentCells.some(({
                              row: r,
                              col: c
                              
                          }) =>
                          grid[r] && grid[r][c] && grid[r][c].element === 'lava'
                      );
                      if (lavaAdjacents) {
                       
                          // Transform adjacent water into steam
                          adjacentCells.forEach(({
                              row: r,
                              col: c
                          }) => {
                            
                              if (grid[r] && grid[r][c] && grid[r][c].element === 'lava') {
                                 
                                 cell.age++;
                                 
                              if(cell.age>=2000){
                                 cell.element='mediumheatrock';
                              }
                              
                             } 
                          });
                      } else{ if (cell.age>=0){cell.age--;;}}if (cell.age < 500 ){cell.element='stone'} }
                      if (cell.element === 'mediumheatrock') {
                      
                      const adjacentCells = [{
                              row: row - 1,
                              col: col
                          }, // Up
                          {
                              row: row + 1,
                              col: col
                          }, // Down
                          {
                              row: row,
                              col: col - 1
                          }, // Left
                          {
                              row: row,
                              col: col + 1
                          } // Right
                      ];
                          adjacentCells.forEach(({ row: r, col: c }) => {
         if (grid[r] && grid[r][c] && elements[grid[r][c].element].flammable) {
             grid[r][c].element = 'fire'; // Ignite flammable material
             grid[r][c].age = 0; // Initialize fire's age
         }
     });
                      // Check for adjacent water cells
                      let lavaAdjacents = adjacentCells.some(({
                              row: r,
                              col: c
                              
                          }) =>
                          grid[r] && grid[r][c] && grid[r][c].element === 'lava'
                      );
                      if (lavaAdjacents) {
                       
                          // Transform adjacent water into steam
                          adjacentCells.forEach(({
                              row: r,
                              col: c
                          }) => {
                            
                              if (grid[r] && grid[r][c] && grid[r][c].element === 'lava') {
                                 
                                 cell.age++;
                                 
                              
                              
                             } 
                          });
                      } else{ if (cell.age>=0){cell.age--;;}}if (cell.age < 2000 ){cell.element='lowheatrock'} }
   if (cell.element === 'cloner') {
                 // Check adjacent cells
                 const adjacentCells = [
                     { row: row - 1, col: col }, // Up
                     { row: row + 1, col: col }, // Down
                     { row: row, col: col - 1 }, // Left
                     { row: row, col: col + 1 }  // Right
                 ];
 
                 // Look for a non-empty adjacent element
                 
                 for (const { row: r, col: c } of adjacentCells) {
                     if (grid[r] && grid[r][c] && grid[r][c].element !== 'empty'&& grid[r][c].element !== 'cloner') {
                         cell.delay++;
                         if(cell.delay===10){
                         // Change the cloner to the element of the adjacent cell
                         cell.element = grid[r][c].element; // Clone the adjacent element
                         cell.age = 0; // Reset age when transformed
                         break; // Exit loop after transforming
                         }
                     }
                 }
             }
             if (cell.element === 'solidcloner') {
                 // Check adjacent cells
                 const adjacentCells = [
                     { row: row - 1, col: col }, // Up
                     { row: row + 1, col: col }, // Down
                     { row: row, col: col - 1 }, // Left
                     { row: row, col: col + 1 }  // Right
                 ];
 
                 // Look for a non-empty adjacent element
                 
                 for (const { row: r, col: c } of adjacentCells) {
                     if (grid[r] && grid[r][c] && grid[r][c].element !== 'empty'&& grid[r][c].element !== 'solidcloner') {
                         cell.delay++;
                         if(cell.delay===10){
                         // Change the cloner to the element of the adjacent cell
                         cell.element = grid[r][c].element; // Clone the adjacent element
                         cell.age = 0; // Reset age when transformed
                         break; // Exit loop after transforming
                         }
                     }
                 }
             }
 // Handle Steam Physics
 if (cell.element === 'steam') {
     cell.age++;
 
     // Check if there's a material above
     const aboveCell = grid[row - 1] && grid[row - 1][col];
     
     // Horizontal movement directions (left and right)
     let directions = [
         { row: 0, col: -1 }, // Left
         { row: 0, col: 1 }   // Right
     ];
 
     // If the cell above is empty, add upward movement as an option
     if (aboveCell && aboveCell.element === 'empty') {
         directions.push({ row: -1, col: 0 }); // Up
     }
 
     // Randomly choose a direction (horizontal or up if possible)
     const randomDirection = directions[Math.floor(Math.random() * directions.length)];
     const newRow = row + randomDirection.row;
     const newCol = col + randomDirection.col;
 
     // Check if the target cell is empty before moving the steam
     if (grid[newRow] && grid[newRow][newCol] && grid[newRow][newCol].element === 'empty') {
         grid[newRow][newCol].element = 'steam';
         grid[newRow][newCol].age = cell.age;
         cell.element = 'empty';
     }
 
     // Steam dissipates after 2 minutes (approximately 2400 frames)
     if (cell.age >= 2000) {
         if (Math.random() < 0.003) { // Adjust the probability as needed (0.01 = 1%)
                     cell.element = 'water'; // Change steam to water
                     continue; // Skip further processing for this cell
                 }
        else{ cell.element = 'empty';}
     }
 }
 
 if (cell.element === 'human') {
                 handleHumanMovement(cell, row, col);
 
             }
 // Handle Steam Physics
 if (cell.element === 'snow' && row < rows - 1) {
     cell.age++;
     cell.delay++;
 
     // Check if there's a material above
   
     const belowCell = grid[row + 1] && grid[row + 1][col];  
     // Horizontal movement directions (left and right)
     let directions = [
         { row: 0, col: -1 }, // Left
         { row: 0, col: 1 }   // Right
     ];
 
     // If the cell above is empty, add upward movement as an option
     if (belowCell && belowCell.element === 'empty') {
         directions.push({ row: +1, col: 0 }); // Up
        
     
 
     // Randomly choose a direction (horizontal or up if possible)
     const srandomDirection = directions[Math.floor(Math.random() * directions.length)];
     const newRow = row + srandomDirection.row;
     const newCol = col + srandomDirection.col;
 
     // Check if the target cell is empty before moving the steam
     if (grid[newRow] && grid[newRow][newCol] && grid[newRow][newCol].element === 'empty') {
         grid[newRow][newCol].element = 'snow';
         grid[newRow][newCol].age = cell.age;
         
         cell.element = 'empty';
     }
     }
   
 }     
 if (cell.element === 'pollen' && row < rows - 1) {
     cell.age++;
     cell.delay++;
 
     // Check if there's a material above
   
     const belowCell = grid[row + 1] && grid[row + 1][col];  
     // Horizontal movement directions (left and right)
     let directions = [
         { row: 0, col: -1 }, // Left
         { row: 0, col: 1 }   // Right
     ];
 
     // If the cell above is empty, add upward movement as an option
     if (belowCell && belowCell.element === 'empty') {
         directions.push({ row: +1, col: 0 }); // Up
        
     
 
     // Randomly choose a direction (horizontal or up if possible)
     const prandomDirection = directions[Math.floor(Math.random() * directions.length)];
     const newRow = row + prandomDirection.row;
     const newCol = col + prandomDirection.col;
 
     // Check if the target cell is empty before moving the steam
     if (grid[newRow] && grid[newRow][newCol] && grid[newRow][newCol].element === 'empty') {
         grid[newRow][newCol].element = 'pollen';
         grid[newRow][newCol].age = cell.age;
         
         cell.element = 'empty';
     }
     }
   
 }     
 if (cell.element === 'blackhole') {
     
                 for (let r = -blackHoleRadius; r <= blackHoleRadius; r++) {
                     for (let c = -blackHoleRadius; c <= blackHoleRadius; c++) {
                         const targetRow = row + r;
                         const targetCol = col + c;
                         const distance = Math.sqrt(r * r + c * c); // Calculate distance from the black hole
 
                         // Check if the target cell is within bounds and not the black hole itself
                         if (grid[targetRow] && grid[targetRow][targetCol] && (targetRow !== row || targetCol !== col)) {
                             // If the distance is within the radius of influence
                             if (distance <= blackHoleRadius) {
                                 const targetElement = grid[targetRow][targetCol];
 
                                 // Move the target cell towards the black hole gradually
                                 if (targetElement.element !== 'empty'&& targetElement.element !== 'blackhole') {
                                     // Calculate the direction vector toward the black hole
                                     const dx = (row - targetRow) * pullSpeed;
                                     const dy = (col - targetCol) * pullSpeed;
    
                                     // Calculate new position
                                     const newRow = targetRow + (dx > 0 ? Math.ceil(dx) : Math.floor(dx));
                                     const newCol = targetCol + (dy > 0 ? Math.ceil(dy) : Math.floor(dy));
 
                                     // Check if the new position is valid and empty
                                     if (grid[newRow] && grid[newRow][newCol].element === 'empty') {
                                         // Move the element to the new position
                                         grid[newRow][newCol].element = targetElement.element; // Move the element
                                         targetElement.element = 'empty'; // Set the original cell to empty
                                         }
                                     
                                 }
                             }
                         }
                     }
                 }
         
             }
 // Handle Steam Physics
 if (cell.element === 'ash' && row < rows - 1) {
     cell.age++;
     cell.delay++;
 
     // Check if there's a material above
   
     const belowCell = grid[row + 1] && grid[row + 1][col];  
     // Horizontal movement directions (left and right)
     let directions = [
         { row: 0, col: -1 }, // Left
         { row: 0, col: 1 }   // Right
     ];
 
     // If the cell above is empty, add upward movement as an option
     if (belowCell && belowCell.element === 'empty') {
         directions.push({ row: +1, col: 0 }); // Up
        
     
 
     // Randomly choose a direction (horizontal or up if possible)
     const arandomDirection = directions[Math.floor(Math.random() * directions.length)];
     const newRow = row + arandomDirection.row;
     const newCol = col + arandomDirection.col;
 
     // Check if the target cell is empty before moving the steam
     if (grid[newRow] && grid[newRow][newCol] && grid[newRow][newCol].element === 'empty') {
         grid[newRow][newCol].element = 'ash';
         grid[newRow][newCol].age = cell.age;
         
         cell.element = 'empty';
     }
     }
   
 }     
   
 if (cell.element === 'fly' && row < rows - 1) {
     cell.age++;
     cell.delay++;
 
     // Check if there's a material above
   
     const belowCell = grid[row + 1] && grid[row + 1][col];  
     // Horizontal movement directions (left and right)
     let directions = [
         { row: 0, col: -1 }, // Left
         { row: 0, col: 1 },   // Right
         {row:1, col: 0},
         {row: -1, col: 0}
     ];
 
     // If the cell above is empty, add upward movement as an option
     if (belowCell && belowCell.element === 'empty') {
        
        
     
 
     // Randomly choose a direction (horizontal or up if possible)
     const frandomDirection = directions[Math.floor(Math.random() * directions.length)];
     const newRow = row + frandomDirection.row;
     const newCol = col + frandomDirection.col;
 
     // Check if the target cell is empty before moving the steam
     if(cell.delay>=10){
     if (grid[newRow] && grid[newRow][newCol] && grid[newRow][newCol].element === 'empty') {
         grid[newRow][newCol].element = 'fly';
         grid[newRow][newCol].age = cell.age;
         cell.delay=0;
         cell.element = 'empty';
     }
     }
 }
   
 }     
 if (cell.element === 'wetsponge') {
     cell.age++;
                        if (!cell.delay) cell.delay = 0; // Initialize delay counter if undefined
                        const adjacentCells = [{
                                row: row + 1,
                                col: col
                            }, // Down
                            {
                                row: row - 1,
                                col: col
                            }, // Up
                            {
                                row: row,
                                col: col - 1
                            }, // Left
                            {
                                row: row,
                                col: col + 1
                            } // Right
                        ];
 
 
 
                        let SAdjacent = adjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'water'
                        );
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
               if(cell.age===1){
                        adjacentCells.forEach(({ row: r, col: c }) => {
         if (grid[r] && grid[r][c] && elements[grid[r][c].element].water) {
           cell.element='wetsponge'; 
             return grid[r][c].element = 'empty'; grid[r][c].age = 0;
            
             
         }
     });
 }
 }
  // Handle lava physics with delay
  if (cell.element === 'sponge') {
                        if (!cell.delay) cell.delay = 0; // Initialize delay counter if undefined
                        const adjacentCells = [{
                                row: row + 1,
                                col: col
                            }, // Down
                            {
                                row: row - 1,
                                col: col
                            }, // Up
                            {
                                row: row,
                                col: col - 1
                            }, // Left
                            {
                                row: row,
                                col: col + 1
                            } // Right
                        ];
 
 
 
                        let SAdjacent = adjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'water'
                        );
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
                        adjacentCells.forEach(({ row: r, col: c }) => {
         if (grid[r] && grid[r][c] && elements[grid[r][c].element].water) {
           cell.element='wetsponge'; 
             return grid[r][c].element = 'empty'; grid[r][c].age = 0;
            
             
         }
     });
 }
                    // Handle lava physics with delay
                    if (cell.element === 'lava') {
                        if (!cell.delay) cell.delay = 0; // Initialize delay counter if undefined
                        const adjacentCells = [{
                                row: row + 1,
                                col: col
                            }, // Down
                            {
                                row: row - 1,
                                col: col
                            }, // Up
                            {
                                row: row,
                                col: col - 1
                            }, // Left
                            {
                                row: row,
                                col: col + 1
                            } // Right
                        ];
 
 
 
                        let waterAdjacent = adjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'water'
                        );
 
 
 
 
 
 
 
 
 
 
 
 
 
                        if (waterAdjacent) {
                            grid[row][col].element = 'stone'; // Turn lava into stone
                          
                        }
 
 
 
 
 
 
                        adjacentCells.forEach(({ row: r, col: c }) => {
         if (grid[r] && grid[r][c] && elements[grid[r][c].element].flammable) {
             grid[r][c].element = 'fire'; // Ignite flammable material
             grid[r][c].age = 0; // Initialize fire's age
         }
     });
 
                        // Check if it can move downwards
                        if (row < rows - 1 && grid[row + 1][col].element === 'empty') {
                            grid[row + 1][col].element = 'lava';
                            cell.element = 'empty';
                            cell.delay = 0; // Reset delay after moving down
                        } else {
                            cell.delay++; // Increment delay counter if stationary
                            if (cell.delay >= 10) { // Modify delay as needed
                                let leftSpread = col > 0 && grid[row][col - 1].element === 'empty';
                                let rightSpread = col < cols - 1 && grid[row][col + 1].element === 'empty';
 
 
 
 
 
 
 
 
 
 
                                if (leftSpread && rightSpread) {
                                    if (Math.random() < 0.5) leftSpread = false;
                                    else rightSpread = false;
                                }
 
                                if (leftSpread) {
                                    grid[row][col - 1].element = 'lava';
                                    cell.element = 'empty';
                                } else if (rightSpread) {
                                    grid[row][col + 1].element = 'lava';
                                    cell.element = 'empty';
                                }
                                cell.delay = 0; // Reset delay after moving sideways
                            }
                        }
                    }
 
                    // Handle lava physics with delay
                    if (cell.element === 'moltensand') {
                        cell.age++
                        if (cell.age > 500) {
                            cell.element = 'glass';
                        }
                        if (!cell.delay) cell.delay = 0; // Initialize delay counter if undefined
                        const adjacentCells = [{
                                row: row + 1,
                                col: col
                            }, // Down
                            {
                                row: row - 1,
                                col: col
                            }, // Up
                            {
                                row: row,
                                col: col - 1
                            }, // Left
                            {
                                row: row,
                                col: col + 1
                            } // Right
                        ];
 
 
                        let waterAdjacent = adjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'water'
                        );
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
                        if (waterAdjacent) {
                            grid[row][col].element = 'glass'; // Turn lava into stone
                          
                        }
 
 
 
 
 
 
 
 
                        // Check if it can move downwards
                        if (row < rows - 1 && grid[row + 1][col].element === 'empty') {
                            grid[row + 1][col].element = 'moltensand';
                            cell.element = 'empty';
                            cell.age++
                            cell.delay = 0; // Reset delay after moving down
                        } else {
                            cell.delay++; // Increment delay counter if stationary
                            if (cell.delay >= 10) { // Modify delay as needed
                                let leftSpread = col > 0 && grid[row][col - 1].element === 'empty';
                                let rightSpread = col < cols - 1 && grid[row][col + 1].element === 'empty';
 
 
 
 
 
                                if (leftSpread && rightSpread) {
                                    if (Math.random() < 0.5) leftSpread = false;
                                    else rightSpread = false;
                                }
 
                             
 
                                if (leftSpread) {
                                    grid[row][col - 1].element = 'moltensand';
                                    cell.element = 'empty';
                                } else if (rightSpread) {
                                    grid[row][col + 1].element = 'moltensand';
                                    cell.element = 'empty';
                                }
                                cell.delay = 0; // Reset delay after moving sideways
                            }
                        }
                    }
                    // Handle lava physics with delay
                    if (cell.element === 'magma') {
                        cell.age++
 
 
 
 
 
 
 
 
 
 
 
                        // Check if it can move downwards
                        if (row < rows - 1 && grid[row + 1][col].element === 'empty') {
                            grid[row + 1][col].element = 'magma';
                            cell.element = 'empty';
                            cell.age++
                            cell.delay = 0; // Reset delay after moving down
                        } else {
                            cell.delay++; // Increment delay counter if stationary
                            if (cell.delay >= 30) { // Modify delay as needed
                                let leftSpread = col  > 0 && grid[row][col - 1].element === 'empty';
                                let rightSpread = col < cols - 1 && grid[row][col + 1].element === 'empty';
 
                                if (leftSpread && rightSpread) {
                                    if (Math.random() < 0.5) leftSpread = false;
                                    else rightSpread = false;
                                }
 
                                if (leftSpread) {
                                    grid[row][col - 1].element = 'magma';
                                    cell.element = 'empty';
                                } else if (rightSpread) {
                                    grid[row][col + 1].element = 'magma';
                                    cell.element = 'empty';
                                }
                                cell.delay = 0; // Reset delay after moving sideways
                            }
                        }
                    }
                    if (cell.element === 'human') {
                       
                       
                        // Define adjacent cells (up, down, left, right, diagonals)
                        const adjacentCells = [{
                                row: row - 1,
                                col: col
                            }, // Up
                            {
                                row: row + 1,
                                col: col
                            }, // Down
                            {
                                row: row,
                                col: col - 1
                            }, // Left
                            {
                                row: row,
                                col: col + 1
                            }, // Right
                            {
                                row: row - 1,
                                col: col - 1
                            }, // Up-Left (Diagonal)
                            {
                                row: row - 1,
                                col: col + 1
                            }, // Up-Right (Diagonal)
                            {
                                row: row + 1,
                                col: col - 1
                            }, // Down-Left (Diagonal)
                            {
                                row: row + 1,
                                col: col + 1
                            } // Down-Right (Diagonal)
                        ];
 
 
 
 
                
 
 
 
                        // Check for adjacent fire cells
                        let mAdjacent = adjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'magma'
                        );
 
 
 
 
 
 
 
 
                        // Ignite oil if adjacent to fire, then skip movement logic
                        if (mAdjacent) {
                         cell.age++;
                         if(cell.age>=10){
                            cell.element = 'ash';
                            cell.age = 0; // Reset age when transformed to fire
                         }
                        }
 
 
                     }
                    if (cell.element === 'oil') {
                        cell.age++;
                       
                        // Define adjacent cells (up, down, left, right, diagonals)
                        const adjacentCells = [{
                                row: row - 1,
                                col: col
                            }, // Up
                            {
                                row: row + 1,
                                col: col
                            }, // Down
                            {
                                row: row,
                                col: col - 1
                            }, // Left
                            {
                                row: row,
                                col: col + 1
                            }, // Right
                            {
                                row: row - 1,
                                col: col - 1
                            }, // Up-Left (Diagonal)
                            {
                                row: row - 1,
                                col: col + 1
                            }, // Up-Right (Diagonal)
                            {
                                row: row + 1,
                                col: col - 1
                            }, // Down-Left (Diagonal)
                            {
                                row: row + 1,
                                col: col + 1
                            } // Down-Right (Diagonal)
                        ];
 
 
 
 
                
 
 
 
                        // Check for adjacent fire cells
                        let fireAdjacent = adjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'fire'
                        );
 
 
 
 
 
 
 
 
                        // Ignite oil if adjacent to fire, then skip movement logic
                        if (fireAdjacent) {
                            cell.element = 'fire';
                            cell.age = 0; // Reset age when transformed to fire
                            
                        }
 
 
 
 
 
 
                        if (row < rows - 1 && grid[row + 1][col].element === 'empty') {
                            grid[row + 1][col].element = 'oil';
                            cell.element = 'empty';
                            cell.delay = 0; // Reset delay after moving down
                        } 
                       
                        // Oil movement logic
                        else {
                            cell.delay++; // Increment delay counter if stationary
                            if (cell.delay >= 0) { // Modify delay as needed
                                let leftSpread = col > 0 && grid[row][col - 1].element === 'empty';
                                let rightSpread = col < cols - 1 && grid[row][col + 1].element === 'empty';
 
 
 
 
 
 
 
 
                                if (leftSpread && rightSpread) {
                                    if (Math.random() < 0.5) leftSpread = false;
                                    else rightSpread = false;
                                }
 
 
 
 
 
 
 
 
                                if (leftSpread) {
                                    grid[row][col - 1].element = 'oil';
                                    cell.element = 'empty';
                                } else if (rightSpread) {
                                    grid[row][col + 1].element = 'oil';
                                    cell.element = 'empty';
                                }
                                cell.delay = 0; // Reset delay after moving sideways
                            }
                        }
                    }
                    if (cell.element === 'syrup') {
                        cell.age++;
                       
 
 
 
 
                
 
 
 
 
 
 
 
 
 
 
 
                        if (row < rows - 1 && grid[row + 1][col].element === 'empty') {
                            grid[row + 1][col].element = 'syrup';
                            cell.element = 'empty';
                            cell.delay = 0; // Reset delay after moving down
                        } 
                       
                        // Oil movement logic
                        else {
                            cell.delay++; // Increment delay counter if stationary
                            if (cell.delay >= 0) { // Modify delay as needed
                                let leftSpread = col > 0 && grid[row][col - 1].element === 'empty';
                                let rightSpread = col < cols - 1 && grid[row][col + 1].element === 'empty';
 
 
 
 
 
 
 
 
                                if (leftSpread && rightSpread) {
                                    if (Math.random() < 0.5) leftSpread = false;
                                    else rightSpread = false;
                                }
 
 
 
 
 
 
 
 
                                if (leftSpread) {
                                    grid[row][col - 1].element = 'syrup';
                                    cell.element = 'empty';
                                } else if (rightSpread) {
                                    grid[row][col + 1].element = 'syrup';
                                    cell.element = 'empty';
                                }
                                cell.delay = 0; // Reset delay after moving sideways
                            }
                        }
                    }
 
 
                   // Handle Steam Physics
 if (cell.element === 'smoke') {
     cell.age++;
 
     // Check if there's a material above
     const aboveCell = grid[row - 1] && grid[row - 1][col];
     
     // Horizontal movement directions (left and right)
     let directions = [
         { row: 0, col: -1 }, // Left
         { row: 0, col: 1 }   // Right
     ];
 
     // If the cell above is empty, add upward movement as an option
     if (aboveCell && aboveCell.element === 'empty') {
         directions.push({ row: -1, col: 0 }); // Up
     }
 
     // Randomly choose a direction (horizontal or up if possible)
     const randomDirection = directions[Math.floor(Math.random() * directions.length)];
     const newRow = row + randomDirection.row;
     const newCol = col + randomDirection.col;
 
     // Check if the target cell is empty before moving the steam
     if (grid[newRow] && grid[newRow][newCol] && grid[newRow][newCol].element === 'empty') {
         grid[newRow][newCol].element = 'smoke';
         grid[newRow][newCol].age = cell.age;
         cell.element = 'empty';
     }
 
     // Steam dissipates after 2 minutes (approximately 2400 frames)
     if (cell.age >= 400) {
         cell.element = 'empty';
     }
 }
  // Handle Steam Physics
  if (cell.element === 'fog') {
     cell.age++;
     cell.delay++;
     // Check if there's a material above
    
     
     // Horizontal movement directions (left and right)
     let directions = [
         { row: 0, col: -1 }, // Left
         { row: 0, col: 1 }   // Right
     ];
 
     // If the cell above is empty, add upward movement as an option
     
 
     // Randomly choose a direction (horizontal or up if possible)
     const randomDirection = directions[Math.floor(Math.random() * directions.length)];
     const newRow = row + randomDirection.row;
     const newCol = col + randomDirection.col;
 
     // Check if the target cell is empty before moving the steam
     if(cell.delay>=40){
     if (grid[newRow] && grid[newRow][newCol] && grid[newRow][newCol].element === 'empty') {
         
         grid[newRow][newCol].element = 'fog';
         grid[newRow][newCol].age = cell.age;
         cell.element = 'empty';
         cell.delay=0;
     }
     }
     // Steam dissipates after 2 minutes (approximately 2400 frames)
     if (cell.age >= 700) {
         cell.element = 'empty';
     }
 }
 
 
 
 
 
 
 
                    // Handle fire physics
                    const directions = [{
                            row: -1,
                            col: 0
                        }, // Up
                        {
                            row: 1,
                            col: 0
                        }, // Down
                        {
                            row: 0,
                            col: -1
                        }, // Left
                        {
                            row: 0,
                            col: 1
                        }, // Right
                        {
                            row: -1,
                            col: -1
                        }, // Up-Left (Diagonal)
                        {
                            row: -1,
                            col: 1
                        }, // Up-Right (Diagonal)
                        {
                            row: 1,
                            col: -1
                        }, // Down-Left (Diagonal)
                        {
                            row: 1,
                            col: 1
                        } // Down-Right (Diagonal)
                    ];
                    if (cell.element === 'fire') {
                     const adjacentCells = [{
                                row: row + 1,
                                col: col
                            }, // Down
                            {
                                row: row - 1,
                                col: col
                            }, // Up
                            {
                                row: row,
                                col: col - 1
                            }, // Left
                            {
                                row: row,
                                col: col + 1
                            } // Right
                        ];
                          // Check for adjacent fire cells
                        let fwAdjacent = adjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'water'
                        );
 
 
 
 
 
 
 
 
                        // Ignite oil if adjacent to fire, then skip movement logic
                        if (fwAdjacent) {
                            cell.element = 'empty';
                            cell.age = 0; // Reset age when transformed to fire
                            
                        }
                        if (cell.age === 10) { // Check every 10 frames
                            for (const {
                                    row: rOffset,
                                    col: cOffset
                                }
                                of directions) {
                                const r = row + rOffset;
                                const c = col + cOffset;
 
                                // Check if the adjacent cell is valid and flammable
                                if (grid[r] && grid[r][c] && elements[grid[r][c].element].flammable) {
                                    grid[r][c].element = 'fire'; // Ignite flammable material
                                }
                            }
                        }
                        cell.age++;
 
 
 
 
 
 
 
 
 
 
 
 
 
                        // Handle smoke and transformation logic as before...
                        if (row > 0 && grid[row - 1][col].element === 'empty') {
                            if (cell.age >= 10 && cell.age <= 13) {
                                grid[row - 1][col].element = 'smoke'; // Place smoke above
                            }
                        }
                        // Transform fire into smoke after 0.5 seconds
                        if (cell.age >= 30) {
                         if (Math.random() < 0.07) {
                            cell.element = 'smoke';
                            cell.age = 0; // Reset age for smoke
                         } else
                         if (Math.random() < 0.001) { 
                             cell.element='ash';
                         } else 
                         cell.element='empty';
                        }
                    }
 
                }
            }
        }
        
                       
        let lastPlacementTime = 0; // Variable to store the last placement time
        const placementCooldown = 25; // Cooldown in milliseconds (adjust as needed)
        function placeElement(x, y) {
     const currentTime = Date.now(); // Get the current time
     // Check if enough time has passed since the last placement
     if (currentTime - lastPlacementTime < placementCooldown) {
         return; // Exit the function if the cooldown has not passed
     }
 
     const colStart = Math.floor(x / voxelSize);
     const rowStart = Math.floor(y / voxelSize);
 
     // Check if the placement is within bounds
     if (rowStart < 0 || rowStart >= rows || colStart < 0 || colStart >= cols) {
         return; // Prevent placing outside the grid
     }
 
     // If the selected element is black hole, check if the cell is empty
     
     
 
     for (let i = 0; i < brushSize; i++) {
         for (let j = 0; j < brushSize; j++) {
             const row = rowStart + i;
             const col = colStart + j;
             
             // Check bounds for brush size
             if (row < 0 || row >= rows || col < 0 || col >= cols ) {
                 continue; // Skip if out of bounds
             }
           
 
             // If the selected element is grass, assign a random color
             if (selectedElement === 'grass') {
                 grid[row][col].element = selectedElement;
                 grid[row][col].age = 0; // Reset age when placed
                 grid[row][col].grassColor = getRandomColorBetween(elements.grass.color1, elements.grass.color2); // Store the random color
             } else if (selectedElement === 'stone') {
                 grid[row][col].element = selectedElement;
                 grid[row][col].age = 0; // Reset age when placed
                 grid[row][col].stoneColor = getRandomColorBetween(elements.stone.color1, elements.stone.color2); // Store the random color
             } else if (selectedElement === 'basalt') {
                 grid[row][col].element = selectedElement;
                 grid[row][col].age = 0; // Reset age when placed
                 grid[row][col].basaltColor = getRandomColorBetween(elements.basalt.color1, elements.basalt.color2); // Store the random color
             } else if (selectedElement === 'obsidian') {
                 grid[row][col].element = selectedElement;
                 grid[row][col].age = 0; // Reset age when placed
                 grid[row][col].obsidianColor = getRandomColorBetween(elements.obsidian.color1, elements.obsidian.color2); // Store the random color
             } else if (selectedElement === 'wood') {
                 grid[row][col].element = selectedElement;
                 grid[row][col].age = 0; // Reset age when placed
                 grid[row][col].woodColor = getRandomColorBetween(elements.wood.color1, elements.wood.color2); // Store the random color
             }  else   if (selectedElement === 'diamond') {
                 grid[row][col].element = selectedElement;
                 grid[row][col].age = 0; // Reset age when placed
                 grid[row][col].diamondColor = getRandomColorBetween(elements.diamond.color1, elements.diamond.color2); // Store the random color
             } else   if (selectedElement === 'moss') {
                 grid[row][col].element = selectedElement;
                 grid[row][col].age = 0; // Reset age when placed
                 grid[row][col].mossColor = getRandomColorBetween(elements.moss.color1, elements.moss.color2); // Store the random color
             } else {
                 grid[row][col].element = selectedElement;
                 grid[row][col].age = 0; // Reset age when placed
             }
         }
     }
 
     lastPlacementTime = currentTime; // Update the last placement time
 }
 
        canvas.addEventListener('mousedown', () => {
           isDrawing = true;
           
        });
 
 
        canvas.addEventListener('mouseup', () => {
            isDrawing = false;
        });
      
        canvas.addEventListener('mousemove', (e) => {
    if (isDrawing) {
      
            const x = e.offsetX;
        const y = e.offsetY;
        placeElement(x, y);
            
          
       
    }

    // Get the mouse position
    const col = Math.floor(e.offsetX / voxelSize);
    const row = Math.floor(e.offsetY / voxelSize);

    // Check if the position is within the bounds of the grid
    if (row >= 0 && row < rows && col >= 0 && col < cols) {
        const hoveredElement = grid[row][col].element; // Get the element type
        const elementName = hoveredElement.charAt(0).toUpperCase() + hoveredElement.slice(1); // Capitalize the first letter

        // Display the element name in the hoverInfo div
        document.getElementById('hoverInfo').innerText = `Element: ${elementName}`;
    } else {
        // Clear the hover info if outside bounds
        document.getElementById('hoverInfo').innerText = '';
    }
});
 
        document.getElementById('brushSize').addEventListener('input', (e) => {
            brushSize = parseInt(e.target.value, 10);
        });
 
 
 
 
 
 
 
 
        window.addEventListener('keydown', (e) => {
            if (e.key.toLowerCase() === 'b') {
                showVoxels = !showVoxels;
            }
        });
 
 
 
 
 
 
 
 
 
 
        let lastFrameTime = 0;
       
let frameDelay = 33; // Target delay in milliseconds
let isPaused = false; // Variable to track if the simulation is paused
let averageFrameTime = frameDelay; // Initial estimate for frame time

// Smoothing factor for moving average (lower values smooth more)
const smoothingFactor = 0.01;

// Pause/Play button logic
document.getElementById('pauseButton').addEventListener('click', () => {
    isPaused = !isPaused; // Toggle the paused state
    const button = document.getElementById('pauseButton');
    if (isPaused) {
        button.classList.remove('pause');
        button.classList.add('play');
    } else {
        button.classList.remove('play');
        button.classList.add('pause');
    }
});

function animate(currentTime) {
    if (!isPaused) {
        const frameTime = currentTime - lastFrameTime;

        // Smoothly adjust the average frame time using exponential moving average
        averageFrameTime += smoothingFactor * (frameTime - averageFrameTime);

        // Dynamically adjust frame delay to target the average
        frameDelay = Math.max(averageFrameTime, 16); // Ensure a minimum delay (16ms ~ 60 FPS)

        if (frameTime >= frameDelay) {
            lastFrameTime = currentTime;
            updateGrid(); // Update the state of the grid
        }
    }

    drawGrid(); // Always draw the grid to keep the elements visible
    requestAnimationFrame(animate); // Continue the animation loop
}

// Start the animation loop
requestAnimationFrame(animate);


        initializeGrid();
    </script>
 </body>
 
 </html>
 
 